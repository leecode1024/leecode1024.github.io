<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">
<script>
    (function () {
        if ('') {
            if (prompt('请输入文章密码') !== '') {
                alert('密码错误！');
                if (history.length === 1) {
                    location.replace("http://leecode1024.github.io"); // 这里替换成你的首页
                } else {
                    history.back();
                }
            }
        }
    })();
</script>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java,数据结构," />





  <link rel="alternate" href="/atom.xml" title="Lee" type="application/atom+xml" />






<meta name="description" content="java数据结构前言这里介绍了基本数据结构，内容易懂，有代码实现，有思路分析，有图解。可以是我们更加容易的去学习数据结构。该笔记参考于">
<meta property="og:type" content="article">
<meta property="og:title" content="java数据结构">
<meta property="og:url" content="https://github.com/leecode1024/leecode1024.github.io/2020/06/29/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Lee">
<meta property="og:description" content="java数据结构前言这里介绍了基本数据结构，内容易懂，有代码实现，有思路分析，有图解。可以是我们更加容易的去学习数据结构。该笔记参考于">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E4%BA%8C%E7%BB%B4%E8%BD%AC%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E4%BA%8C%E7%BB%B4%E4%B8%8E%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%BA%92%E8%BD%AC.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E9%98%9F%E5%88%97.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%B7%BB%E5%8A%A0.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E5%9B%BE%E8%A7%A3.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E7%8E%AF%E5%BD%A2%E5%8D%95%E9%87%8F%E9%93%BE%E8%A1%A8%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%87%BA%E5%9C%88.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%A0%88.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A0%88.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E8%BF%B7%E5%AE%AB.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%88%86%E6%B2%BB.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%90%88%E5%B9%B6%E7%9B%B8%E9%82%BB%E5%AD%90%E5%BA%8F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F1-2.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F3.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%AF%94%E8%BE%83.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%93%88%E5%B8%8C%E8%A1%A81.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%93%88%E5%B8%8C%E8%A1%A82.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%A0%91%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%E5%9B%BE.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%9101.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A4%A7%E9%A1%B6%E5%A0%86%E4%B8%BE%E4%BE%8B.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%B0%8F%E9%A1%B6%E5%A0%86%E4%B8%BE%E4%BE%8B.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A401.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A402.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A403.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A404.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A405.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A406.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A407.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A408.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%BE%E4%BE%8B.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%88%9B%E5%BB%BA%E5%9B%BE%E8%A7%A3.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%8101.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%8102.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%8103.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%8104.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%B8%BE%E4%BE%8B.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL01.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL%E5%8F%B3%E6%97%8B%E8%BD%AC.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL02.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL%E5%B7%A6%E6%97%8B%E8%BD%AC.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL%E5%8F%8C%E6%97%8B%E8%BD%AC%E5%8F%B3%E6%97%8B%E8%BD%AC%E4%B8%8D%E6%88%90%E7%AB%8B.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL%E5%85%88%E5%B7%A6%E5%90%8E%E5%8F%B3.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL%E5%8F%8C%E6%97%8B%E8%BD%AC%E5%B7%A6%E6%97%8B%E8%BD%AC%E4%B8%8D%E6%88%90%E7%AB%8B.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL%E5%85%88%E5%8F%B3%E5%90%8E%E5%B7%A6.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A4%9A%E5%8F%89%E6%A0%91%E4%B8%BE%E4%BE%8B.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/B%E6%A0%91%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/2-3%E6%A0%91.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/B%E6%A0%91.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/B%2B%E6%A0%91.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/B%E6%98%9F%E6%A0%91.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%9B%BE.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%97%A0%E5%90%91%E5%9B%BE.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%9C%89%E5%90%91%E5%9B%BE%E5%92%8C%E5%B8%A6%E6%9D%83%E5%9B%BE.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png">
<meta property="og:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E9%82%BB%E6%8E%A5%E8%A1%A8.png">
<meta property="article:published_time" content="2020-06-29T08:57:38.000Z">
<meta property="article:modified_time" content="2020-08-05T03:15:55.231Z">
<meta property="article:author" content="李义">
<meta property="article:tag" content="java">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/leecode1024/leecode1024.github.io/2020/06/29/java数据结构/"/>





  <title>java数据结构 | Lee</title>
  









<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lee</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">捣鼓一个博客玩</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/leecode1024/leecode1024.github.io/2020/06/29/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李义">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lee">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java数据结构</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-29T16:57:38+08:00">
                2020-06-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-08-05T11:15:55+08:00">
                2020-08-05
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2020/06/29/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="leancloud_visitors" data-flag-title="java数据结构">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  45.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  193
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="java数据结构"><a href="#java数据结构" class="headerlink" title="java数据结构"></a>java数据结构</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这里介绍了基本数据结构，内容易懂，有代码实现，有思路分析，有图解。可以是我们更加容易的去学习数据结构。该笔记参考于</p>
<a id="more"></a>

<h1 id="稀疏sparsearray数组"><a href="#稀疏sparsearray数组" class="headerlink" title="稀疏sparsearray数组"></a>稀疏sparsearray数组</h1><p>编写的五子棋程序中，有存盘退出和续上盘的功能。</p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5.png" alt="image-20200609144127262"></p>
<p>分析问题:<br>因为该二维数组的很多值是默认值0, 因此<strong>记录了很多没有意义的数据.</strong>-&gt;稀疏数组。</p>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul>
<li>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</li>
<li>稀疏数组的处理方法是:<ul>
<li>记录数组一共有几行几列，有多少个不同的值</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</li>
</ul>
</li>
<li>稀疏数组第一行，也就是索引为0的行，记录原二维数组的基本信息【多少行，多少列，多少有效值】</li>
<li>稀疏矩阵其他行，记录原二维数组的有效值信息【原第几行，原第几列，值】</li>
<li>因此二维数组转换得到的稀疏矩阵是N行3列。</li>
</ul>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E4%BA%8C%E7%BB%B4%E8%BD%AC%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5.png" alt=""></p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E4%BA%8C%E7%BB%B4%E4%B8%8E%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E4%BA%92%E8%BD%AC.png" alt="image-20200609144831136"></p>
<p>类似于棋盘，没有棋子的位置保存为0，黑棋保存1，蓝棋保存2</p>
<h2 id="二维数组与稀疏矩阵互相转换的思路"><a href="#二维数组与稀疏矩阵互相转换的思路" class="headerlink" title="二维数组与稀疏矩阵互相转换的思路"></a>二维数组与稀疏矩阵互相转换的思路</h2><h3 id="二维-转-稀疏"><a href="#二维-转-稀疏" class="headerlink" title="二维 转 稀疏"></a>二维 转 稀疏</h3><ol>
<li>遍历原始的二维数组，得到有效数据个数 sum，因为第0行保存原数组基本信息，所以总行数为sum+1。</li>
<li>根据sum就可以创建稀疏数组  <code>int[sum+1][3]sparseArr</code>。</li>
<li>将二维数组的有效值存入稀疏数组。</li>
</ol>
<h3 id="稀疏-转-二维数组"><a href="#稀疏-转-二维数组" class="headerlink" title="稀疏 转 二维数组"></a>稀疏 转 二维数组</h3><ol>
<li>先读取稀疏数组第一行，根据第一行数据创建原始二维数组，比如上面的 <code>chessArr2  = int[11][11]</code></li>
<li>在读取稀疏数组后几行数据，并赋值给原数组即可。</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> sparseArray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建一个原始二维数组11*11</span></span><br><span class="line">		<span class="comment">//0表示没有棋子，1表示黑子，2表示蓝子</span></span><br><span class="line">		<span class="keyword">int</span>[][] chessArr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">		chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">		chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">		<span class="comment">//输出原始的二维数组</span></span><br><span class="line">		System.out.println(<span class="string">"原始的二维数组"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;<span class="comment">//每一行</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;<span class="comment">//每一行的每一个数据</span></span><br><span class="line">				System.out.printf(<span class="string">"%d\t"</span>,data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将二维数组 转 稀疏数组</span></span><br><span class="line">		<span class="comment">/* 1.先遍历二维数组，得到非零数据的个数</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; <span class="number">11</span>;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					sum++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//2.创建对应的稀疏数组</span></span><br><span class="line">		<span class="keyword">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="keyword">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">		<span class="comment">//给稀疏数组赋值</span></span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历二位数组，将非零的值存到稀疏数组中</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//用于记录是第几个非零数据</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; <span class="number">11</span>;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					count++;</span><br><span class="line">					sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">					sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">					sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//输出稀疏数组</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">"得到的稀疏数组为如下形式："</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;sparseArr.length;i++) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>,sparseArr[i][<span class="number">0</span>],sparseArr[i][<span class="number">1</span>],sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//稀疏数组转回二维数组</span></span><br><span class="line">		<span class="comment">//1.先读取稀疏数组第一行，创建原始二维数组</span></span><br><span class="line">		<span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[ sparseArr[<span class="number">0</span>][<span class="number">0</span>] ][ sparseArr[<span class="number">0</span>][<span class="number">1</span>] ];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;sparseArr.length;i++) &#123;</span><br><span class="line">			chessArr2[ sparseArr[i][<span class="number">0</span>] ][ sparseArr[i][<span class="number">1</span>] ] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"恢复后的二维数组"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;<span class="comment">//每一行</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;<span class="comment">//每一行的每一个数据</span></span><br><span class="line">				System.out.printf(<span class="string">"%d\t"</span>,data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="队列介绍"><a href="#队列介绍" class="headerlink" title="队列介绍"></a>队列介绍</h2><ol>
<li>队列是一个<strong>有序列表</strong>，可以用<strong>数组</strong>或<strong>链表</strong>来实现。</li>
<li>遵循<strong>先入先出</strong>的原则，即：先存入队列的数据，要先取出。后存入的要后取出。</li>
</ol>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E9%98%9F%E5%88%97.png" alt=""></p>
<h2 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h2><p><strong>思路</strong></p>
<ul>
<li><p>队列本身是有序列表，若使用数组结构来存储队列数据，则队列数组的声明如上图，其中<strong>maxSize</strong>是该队列的<strong>最大容量</strong>。</p>
</li>
<li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量front及rear分别记录队列前后端的下标。</p>
<ul>
<li>front会随着数据输出而改变。</li>
<li>rear则是随着数据输入而改变。</li>
</ul>
</li>
<li><p>当我们将数据存入队列时称为“addQueue”，addQueue的处理需要两个步骤</p>
<ol>
<li>将为指针往后移：rear+1,<strong>当front==rear时【队列空】</strong></li>
<li>若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。<strong>rear == maxSize-1【队列满】</strong>，因为下标从0开始所以maxSize要-1</li>
</ol>
</li>
<li><p>注意这里的rear和front的初始值都为-1.</p>
</li>
<li><p><strong>这里的front指向第一个元素的前一位</strong>！</p>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用数组模拟队列，编写一个ArrayQueue类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//表示数组最大容量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//指向队头</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">//指向队尾</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//该数组用于存放数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建队列的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">		maxSize = arrMaxSize;</span><br><span class="line">		arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">		front = -<span class="number">1</span>;<span class="comment">//指向队列头部，未赋值前分析出front指向队列头的前一个位置</span></span><br><span class="line">		rear = -<span class="number">1</span>;<span class="comment">//指向队列尾部，就是最后一个数据</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断队列是否满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear == maxSize-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断队列是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear == front;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加数据到队列</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断队列是否满</span></span><br><span class="line">		<span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列满，不能加入数据"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		rear++;<span class="comment">//让rear后移，这里先后移然后赋值</span></span><br><span class="line">		arr[rear] = n;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//取数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断队列是否空</span></span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			<span class="comment">//通过抛出异常来处理</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，不能取数据"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		front++;<span class="comment">//头指针后移</span></span><br><span class="line">		<span class="keyword">return</span> arr[front];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示队列所有数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//遍历</span></span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列空的，没有数据"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"arr[%d]=%d\n"</span>,i,arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//显示队列的头数据，注意不是取出数据，仅仅显示</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr[front+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试以上代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建一个队列</span></span><br><span class="line">		ArrayQueue aq = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">char</span> key = <span class="string">' '</span>;<span class="comment">//接收用户输入</span></span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">		<span class="comment">//输出一个菜单</span></span><br><span class="line">		<span class="keyword">while</span>(loop) &#123;</span><br><span class="line">			System.out.println(<span class="string">"s(show):显示队列"</span>);</span><br><span class="line">			System.out.println(<span class="string">"e(exit):退出程序"</span>);</span><br><span class="line">			System.out.println(<span class="string">"a(add):添加数据到队列"</span>);</span><br><span class="line">			System.out.println(<span class="string">"g(get):从队列取数据"</span>);</span><br><span class="line">			System.out.println(<span class="string">"h(show):查看队列头数据"</span>);</span><br><span class="line">			key = sc.next().charAt(<span class="number">0</span>);<span class="comment">//接受一个字符</span></span><br><span class="line">			<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">				aq.showQueue();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">				System.out.println(<span class="string">"请输入一个数"</span>);</span><br><span class="line">				<span class="keyword">int</span> value = sc.nextInt();</span><br><span class="line">				aq.addQueue(value);;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'g'</span>:</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">int</span> result = aq.getQueue();</span><br><span class="line">					System.out.printf(<span class="string">"取出的数据是%d\n"</span>,result);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">					System.out.println(e.getMessage());</span><br><span class="line">				&#125;				</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'h'</span>:<span class="comment">//查看队头数据</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">int</span> r = aq.headQueue();</span><br><span class="line">					System.out.printf(<span class="string">"队列头的数据是%d\n"</span>,r);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">					System.out.println(e.getMessage());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">				sc.close();</span><br><span class="line">				loop=<span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;	</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				System.out.println();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"程序退出"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们通过测试可以发现，当我们创建了一个队列，随着我们不断地进队、出队操作，front与rear越来越靠后，而它们之前的空间就无法被再次使用，以至于这个队列用一次就不能用了。<br>为了解决这个问题，我们引入了循环队列。</p>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>对前面的数组模拟队列的优化，充分利用数组，因此将数组看做是一个环形（通过<strong>取模</strong>实现）。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>尾指针的下一个为头指针时表示队列满，即：将队列容量空出一个作为约定。<ul>
<li>这里的尾指针指向最后一个元素的下一位。</li>
<li>队列满条件【(rear+1)%maxSize == front】</li>
<li>实际最大存储maxSize-1个数据，因为要空出一个空间。</li>
<li>这里的设定不唯一，后面我们会总结一下！</li>
</ul>
</li>
<li>rear == front【队列空】</li>
</ul>
<h3 id="编写环形队列思路"><a href="#编写环形队列思路" class="headerlink" title="编写环形队列思路"></a>编写环形队列思路</h3><ul>
<li>front变量的含义嘴一个调整：<strong>front就指向队列的第一个元素</strong>，<strong>初值=0</strong></li>
<li><strong>rear指向最后一个元素后一个位置</strong>，因为空出一个空间作为约定。<strong>初值=0</strong></li>
<li>队列满：<code>(rear+1)%maxSize == front</code>【满】</li>
<li>队列空：<code>rear == front</code>【空】</li>
<li>队列中的有效数据个数：<code>(rear-front+maxSize)%maxSize</code></li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArray</span></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * front指向队列的第一个元素，也就是说arr[front]就是头部数据</span></span><br><span class="line"><span class="comment">	 * front初始值=0</span></span><br><span class="line"><span class="comment">	 * rear指向最后一个元素的后一个位置，因为希望空出一个空间作为约束</span></span><br><span class="line"><span class="comment">	 * rear初始值=0</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//表示数组最大容量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rear; </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//该数组用于存放数据</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CircleArray</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">		maxSize = arrMaxSize;</span><br><span class="line">		arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断队列是否满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断队列是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear == front;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加数据到队列	</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断队列是否满</span></span><br><span class="line">		<span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列满，不能加入数据"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//直接将数据加入</span></span><br><span class="line">		arr[rear] = n;</span><br><span class="line">		<span class="comment">//将rear后移，这里必须考虑取模</span></span><br><span class="line">		rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//取数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断队列是否空</span></span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			<span class="comment">//通过抛出异常来处理</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，不能取数据"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//这里需要分析出 front是指向队列的第一个元素</span></span><br><span class="line">		<span class="comment">/* 1.先把front的值保存到一个临时变量</span></span><br><span class="line"><span class="comment">		 * 2.将front后移</span></span><br><span class="line"><span class="comment">		 * 3.将临时保存的变量返回</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		<span class="keyword">int</span> value =arr[front];</span><br><span class="line">		front = (front+<span class="number">1</span>) % maxSize;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//显示队列所有数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//遍历</span></span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列空的，没有数据"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//思路：从front开始遍历，遍历多少个元素</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = front; i&lt;front+size();i++ ) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"arr[%d]=%d\n"</span>,i % maxSize,arr[i%maxSize]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//求出当前队列有效数据的个数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (rear+maxSize-front)%maxSize;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//显示队列的头数据，注意不是取出数据，仅仅显示</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr[front];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试上面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建一个队列</span></span><br><span class="line">		CircleArray aq = <span class="keyword">new</span> CircleArray(<span class="number">4</span>);<span class="comment">//其队列有效数据最大是3，因为有一个空间作为约定</span></span><br><span class="line">		<span class="keyword">char</span> key = <span class="string">' '</span>;<span class="comment">//接收用户输入</span></span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">		<span class="comment">//输出一个菜单</span></span><br><span class="line">		<span class="keyword">while</span>(loop) &#123;</span><br><span class="line">			System.out.println(<span class="string">"s(show):显示队列"</span>);</span><br><span class="line">			System.out.println(<span class="string">"e(exit):退出程序"</span>);</span><br><span class="line">			System.out.println(<span class="string">"a(add):添加数据到队列"</span>);</span><br><span class="line">			System.out.println(<span class="string">"g(get):从队列取数据"</span>);</span><br><span class="line">			System.out.println(<span class="string">"h(show):查看队列头数据"</span>);</span><br><span class="line">			key = sc.next().charAt(<span class="number">0</span>);<span class="comment">//接受一个字符</span></span><br><span class="line">			<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">				aq.showQueue();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">				System.out.println(<span class="string">"请输入一个数"</span>);</span><br><span class="line">				<span class="keyword">int</span> value = sc.nextInt();</span><br><span class="line">				aq.addQueue(value);;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'g'</span>:</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">int</span> result = aq.getQueue();</span><br><span class="line">					System.out.printf(<span class="string">"取出的数据是%d\n"</span>,result);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">					System.out.println(e.getMessage());</span><br><span class="line">				&#125;				</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'h'</span>:<span class="comment">//查看队头数据</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">int</span> r = aq.headQueue();</span><br><span class="line">					System.out.printf(<span class="string">"队列头的数据是%d\n"</span>,r);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">					System.out.println(e.getMessage());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">				sc.close();</span><br><span class="line">				loop=<span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;	</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				System.out.println();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"程序退出"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么循环队列要空一个空间作为约定？"><a href="#为什么循环队列要空一个空间作为约定？" class="headerlink" title="为什么循环队列要空一个空间作为约定？"></a>为什么循环队列要空一个空间作为约定？</h3><p>在循环队列中，入队时，尾指针追赶头指针；出队时，头指针追赶尾指针。这样就造成了【队满】与【队空】的状态一样，即：入队，尾指针追上了头指针，此时rear==front  【队满】；出队，头指针追上了尾指针，此时reat==front【队空】。所以无法通过rear==front来判断队空或队满。解决方法至少有三种：</p>
<ol>
<li>另外增加布尔变量来表示队空和队满。</li>
<li>少用一个空间，比如我们这种形式。</li>
<li>使用计数器，记录队列中元素的总数。</li>
</ol>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>单链表是有序列表，内存中存储如下：</p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E9%93%BE%E8%A1%A8.png" alt=""></p>
<ul>
<li>链表是以节点的方式来寻出，是链式存储</li>
<li>每个节点包含<strong>data域</strong>，<strong>next域</strong>：指向下一个节点</li>
<li>如图发现链表的各个节点<strong>不一定是连续</strong>的，逻辑上连续，物理上不一定连续。</li>
<li>链表分带头结点的链表和没有头结点的链表，根据实际的需求来确定</li>
</ul>
<p>带头结点的逻辑结构示意图</p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8.png" alt=""></p>
<h3 id="单链表案例"><a href="#单链表案例" class="headerlink" title="单链表案例"></a>单链表案例</h3><p>使用带head头的单向链表实现，水浒英雄排行榜管理，完成对英雄人物的增删改查操作。</p>
<h4 id="定义节点类"><a href="#定义节点类" class="headerlink" title="定义节点类"></a><strong>定义节点类</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义HeroNode</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> String nickname;</span><br><span class="line">	<span class="keyword">public</span> HeroNode next;<span class="comment">//指向下一个节点</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no,String name,String nickName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">		<span class="keyword">this</span>.nickname=nickName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为了显示方便，重写toString</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span> + nickname + <span class="string">"]"</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义单链表类"><a href="#定义单链表类" class="headerlink" title="定义单链表类"></a>定义单链表类</h4><p>这里面的其他方法，我们一一介绍，然后加到该类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义SingleLinkList管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span></span>&#123;</span><br><span class="line">	<span class="comment">//先初始化头结点，头结点不要动，不存放具体数据</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h5><p><strong>第一种，不考虑顺序的添加。</strong><br><strong>思路</strong></p>
<ol>
<li><p>先创建一个head头结点，作用就是表示单链表的头。</p>
</li>
<li><p>后面每加一个节点，就直接加入到链表的最后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加节点到单向链表</span></span><br><span class="line">	<span class="comment">//当不考虑编号的顺序时</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1.找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">	 * 2.将最后这个节点的next指向新节点</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//因为head节点不能动，因此需要一个辅助节点</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="comment">//遍历链表，找到最后</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">//找到链表最后</span></span><br><span class="line">			<span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果没有找到最后，将temp后移</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当退出循环时，temp就指向了链表最后</span></span><br><span class="line">		temp.next = heroNode;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p><strong>第二种，考虑顺序</strong></p>
<p><strong>思路</strong></p>
<ol>
<li>首先找到新添加节点的位置，是通过辅助变量temp，通过遍历来搞定。temp要指向添加位置的前一个节点。</li>
<li>新节点.next = temp.next。新节点指向添加位置的后一个节点。</li>
<li>temp.next = 新节点。添加位置的前一个节点的next指向新节点。</li>
</ol>
<p><strong>示意图</strong></p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%8D%95%E9%93%BE%E8%A1%A8%E6%B7%BB%E5%8A%A0.png" alt=""></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种方式再添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line">	<span class="comment">//如果有这个排名。则添加失败</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//因为头结点不能动，因此通过辅助指针帮助找到添加的位置</span></span><br><span class="line">		<span class="comment">//因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//标志添加的编号是否存在，默认false</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明temp在链表最后了</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.next.no &gt; heroNode.no) &#123;<span class="comment">//位置找到，就在temp后面</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no == heroNode.no) &#123;<span class="comment">//说明希望添加的heroNode的编号已然存在</span></span><br><span class="line">				flag = <span class="keyword">true</span>;<span class="comment">//说明编号存在</span></span><br><span class="line">				<span class="keyword">break</span>;				</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">//后移，遍历当前链表</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断flag的值</span></span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;<span class="comment">//说明编号存在，不能添加</span></span><br><span class="line">			System.out.printf(<span class="string">"准备插入的英雄的编号 %d 已经存在，不能加入\n"</span>,heroNode.no);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//插入到链表中，temp的后面</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 1.先让heroNode.next =temp.next</span></span><br><span class="line"><span class="comment">			 * 2.再让temp.next = heroNode</span></span><br><span class="line"><span class="comment">			 * */</span></span><br><span class="line">			heroNode.next = temp.next;</span><br><span class="line">			temp.next = heroNode;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="显示链表内容"><a href="#显示链表内容" class="headerlink" title="显示链表内容"></a>显示链表内容</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//先判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//因为头节点不能动，需要辅助变量</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">//判断是否到最后</span></span><br><span class="line">			<span class="keyword">if</span>(temp==<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//输出节点的信息</span></span><br><span class="line">			System.out.println(temp);</span><br><span class="line">			<span class="comment">//将temp后移</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修改节点内容"><a href="#修改节点内容" class="headerlink" title="修改节点内容"></a>修改节点内容</h5><p><strong>思路</strong></p>
<ol>
<li>先通过遍历找到找到该节点。</li>
<li>然后为对应属性赋值。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改节点的信息，根据no来修改，即no不可变</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断空</span></span><br><span class="line">		<span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空----"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//找到修改的节点，根据no</span></span><br><span class="line">		<span class="comment">//定义辅助变量</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//表示是否找到该节点</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//表示链表已经遍历完</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.no == newHeroNode.no) &#123;<span class="comment">//找到要修改的节点</span></span><br><span class="line">				flag=<span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//根据flag判断是否找到要修改的节点</span></span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			temp.name = newHeroNode.name;</span><br><span class="line">			temp.nickname = newHeroNode.nickname;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//没有找到</span></span><br><span class="line">			System.out.printf(<span class="string">"没有找到编号 %d 的节点，不能修改\n"</span>,newHeroNode.no);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h5><p><strong>思路</strong></p>
<ol>
<li>先创建temp辅助指针，通过遍历找到要删除节点的前一个节点。</li>
<li>将temp.next = temp.next.next。将要删除节点的前一个节点的next指向要删除节点的后一个节点。</li>
<li>被删除节点会因为没有其他引用，而被垃圾回收机制回收。</li>
</ol>
<p><strong>示例图</strong></p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9.png" alt=""></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除节点</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1.head不动，用temp辅助借调找到待删除节点的前一个节点</span></span><br><span class="line"><span class="comment">	 * 2.说明我们在比较时，是temp.next.no和需要删除的节点no比较 </span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//表示是否找到待删除的节点</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123;<span class="comment">//已经到链表的最后</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.next.no == no) &#123;</span><br><span class="line">				<span class="comment">//找到待删除节点的前一个节点temp</span></span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">//后移，遍历链表</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			<span class="comment">//找到可以删除</span></span><br><span class="line">			temp.next = temp.next.next;</span><br><span class="line">			<span class="comment">/*解释一下，temp现在指向待删除节点的前一个节点，temp.next本来指向要删除的节点</span></span><br><span class="line"><span class="comment">			 * 把要删除的节点删除后，temp.next要指向要删除节点的后一个节点，而temp.next.next指向的就是要删除节点的后一个节点</span></span><br><span class="line"><span class="comment">			 * 所以要删除节点的前一个节点，指向要删除节点的后一个节点就是temp.next = temp.next.next</span></span><br><span class="line"><span class="comment">			 * */</span></span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.printf(<span class="string">"没有找到 %d 号节点，无法删除\n"</span>,no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="代码综合"><a href="#代码综合" class="headerlink" title="代码综合"></a>代码综合</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义SingleLinkList管理我们的英雄</span></span><br><span class="line"><span class="keyword">class</span> SingleLinkedList&#123;</span><br><span class="line">	<span class="comment">//先初始化头结点，头结点不要动，不存放具体数据</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加节点到单向链表</span></span><br><span class="line">	<span class="comment">//当不考虑编号的顺序时</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1.找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">	 * 2.将最后这个节点的next指向新节点</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> add(HeroNode heroNode) &#123;</span><br><span class="line">		<span class="comment">//因为head节点不能动，因此需要一个辅助节点</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="comment">//遍历链表，找到最后</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">//找到链表最后</span></span><br><span class="line">			<span class="keyword">if</span>(temp.<span class="keyword">next</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果没有找到最后，将temp后移</span></span><br><span class="line">			temp = temp.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当退出循环时，temp就指向了链表最后</span></span><br><span class="line">		temp.<span class="keyword">next</span> = heroNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//第二种方式再添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line">	<span class="comment">//如果有这个排名。则添加失败</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> addByOrder(HeroNode heroNode) &#123;</span><br><span class="line">		<span class="comment">//因为头结点不能动，因此通过辅助指针帮助找到添加的位置</span></span><br><span class="line">		<span class="comment">//因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//标志添加的编号是否存在，默认false</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp.<span class="keyword">next</span> == <span class="keyword">null</span>) &#123;<span class="comment">//说明temp在链表最后了</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.<span class="keyword">next</span>.no &gt; heroNode.no) &#123;<span class="comment">//位置找到，就在temp后面</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.<span class="keyword">next</span>.no == heroNode.no) &#123;<span class="comment">//说明希望添加的heroNode的编号已然存在</span></span><br><span class="line">				flag = <span class="keyword">true</span>;<span class="comment">//说明编号存在</span></span><br><span class="line">				<span class="keyword">break</span>;				</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.<span class="keyword">next</span>;<span class="comment">//后移，遍历当前链表</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断flag的值</span></span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;<span class="comment">//说明编号存在，不能添加</span></span><br><span class="line">			System.out.printf(<span class="string">"准备插入的英雄的编号 %d 已经存在，不能加入\n"</span>,heroNode.no);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//插入到链表中，temp的后面</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 1.先让heroNode.next =temp.next</span></span><br><span class="line"><span class="comment">			 * 2.再让temp.next = heroNode</span></span><br><span class="line"><span class="comment">			 * */</span></span><br><span class="line">			heroNode.<span class="keyword">next</span> = temp.<span class="keyword">next</span>;</span><br><span class="line">			temp.<span class="keyword">next</span> = heroNode;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//显示链表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> list() &#123;</span><br><span class="line">		<span class="comment">//先判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span>(head.<span class="keyword">next</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//因为头节点不能动，需要辅助变量</span></span><br><span class="line">		HeroNode temp = head.<span class="keyword">next</span>;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">//判断是否到最后</span></span><br><span class="line">			<span class="keyword">if</span>(temp==<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//输出节点的信息</span></span><br><span class="line">			System.out.<span class="keyword">println</span>(temp);</span><br><span class="line">			<span class="comment">//将temp后移</span></span><br><span class="line">			temp = temp.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//修改节点的信息，根据no来修改，即no不可变</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> update(HeroNode newHeroNode) &#123;</span><br><span class="line">		<span class="comment">//判断空</span></span><br><span class="line">		<span class="keyword">if</span>(head.<span class="keyword">next</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(<span class="string">"链表为空----"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//找到修改的节点，根据no</span></span><br><span class="line">		<span class="comment">//定义辅助变量</span></span><br><span class="line">		HeroNode temp = head.<span class="keyword">next</span>;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//表示是否找到该节点</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//表示链表已经遍历完</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.no == newHeroNode.no) &#123;<span class="comment">//找到要修改的节点</span></span><br><span class="line">				flag=<span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//根据flag判断是否找到要修改的节点</span></span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			temp.name = newHeroNode.name;</span><br><span class="line">			temp.nickname = newHeroNode.nickname;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//没有找到</span></span><br><span class="line">			System.out.printf(<span class="string">"没有找到编号 %d 的节点，不能修改\n"</span>,newHeroNode.no);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除节点</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1.head不动，用temp辅助借调找到待删除节点的前一个节点</span></span><br><span class="line"><span class="comment">	 * 2.说明我们在比较时，是temp.next.no和需要删除的节点no比较</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> del(<span class="keyword">int</span> no) &#123;</span><br><span class="line">		HeroNode temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//表示是否找到待删除的节点</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp.<span class="keyword">next</span> == <span class="keyword">null</span>) &#123;<span class="comment">//已经到链表的最后</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.<span class="keyword">next</span>.no == no) &#123;</span><br><span class="line">				<span class="comment">//找到待删除节点的前一个节点temp</span></span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.<span class="keyword">next</span>;<span class="comment">//后移，遍历链表</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			<span class="comment">//找到可以删除</span></span><br><span class="line">			temp.<span class="keyword">next</span> = temp.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">			<span class="comment">/*解释一下，temp现在指向待删除节点的前一个节点，temp.next本来指向要删除的节点</span></span><br><span class="line"><span class="comment">			 * 把要删除的节点删除后，temp.next要指向要删除节点的后一个节点，而temp.next.next指向的就是要删除节点的后一个节点</span></span><br><span class="line"><span class="comment">			 * 所以要删除节点的前一个节点，指向要删除节点的后一个节点就是temp.next = temp.next.next</span></span><br><span class="line"><span class="comment">			 * */</span></span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.printf(<span class="string">"没有找到 %d 号节点，无法删除\n"</span>,no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//测试</span></span><br><span class="line">		HeroNode h1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">"宋江"</span>,<span class="string">"及时雨"</span>);</span><br><span class="line">		HeroNode h2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>,<span class="string">"卢俊义"</span>,<span class="string">"玉麒麟"</span>);</span><br><span class="line">		HeroNode h3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">"吴用"</span>,<span class="string">"智多星"</span>);</span><br><span class="line">		HeroNode h4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">"公孙胜"</span>,<span class="string">"入云龙"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建链表</span></span><br><span class="line">		SingleLinkedList s1 = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//加入</span></span><br><span class="line"><span class="comment">//		s1.add(h1);</span></span><br><span class="line"><span class="comment">//		s1.add(h2);</span></span><br><span class="line"><span class="comment">//		s1.add(h3);</span></span><br><span class="line"><span class="comment">//		s1.add(h4);</span></span><br><span class="line">		s1.addByOrder(h1);</span><br><span class="line">		s1.addByOrder(h4);</span><br><span class="line">		s1.addByOrder(h3);</span><br><span class="line">		s1.addByOrder(h2);</span><br><span class="line">		s1.addByOrder(h2);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//测试修改节点</span></span><br><span class="line">		System.out.println(<span class="string">"修改前的链表"</span>);</span><br><span class="line">		<span class="comment">//显示</span></span><br><span class="line">		s1.list();</span><br><span class="line">		HeroNode newHeroNode = <span class="keyword">new</span> HeroNode(<span class="number">4</span>,<span class="string">"公孙小胜"</span>,<span class="string">"入云龙儿"</span>);</span><br><span class="line">		s1.update(newHeroNode);</span><br><span class="line">		HeroNode newHeroNode2 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>,<span class="string">"公孙小胜"</span>,<span class="string">"入云龙儿"</span>);<span class="comment">//这里测试没有找到</span></span><br><span class="line">		s1.update(newHeroNode2);</span><br><span class="line">		System.out.println(<span class="string">"修改后的链表"</span>);</span><br><span class="line">		s1.list();</span><br><span class="line">		<span class="comment">//测试删除</span></span><br><span class="line">		s1.del(<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">"删除以后的链表"</span>);</span><br><span class="line">		s1.list();</span><br><span class="line">		<span class="comment">//测试删除失败</span></span><br><span class="line">		s1.del(<span class="number">88</span>);</span><br><span class="line">		s1.del(<span class="number">4</span>);		</span><br><span class="line">		s1.list();		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表面试题"><a href="#单链表面试题" class="headerlink" title="单链表面试题"></a>单链表面试题</h3><h5 id="1-求单链表中有效节点的个数。"><a href="#1-求单链表中有效节点的个数。" class="headerlink" title="1.求单链表中有效节点的个数。"></a>1.求单链表中有效节点的个数。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法：获取到单链表的节点个数（如果是带头结点的链表，需求不统计头结点）</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;<span class="comment">//传头结点进来</span></span><br><span class="line">		<span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//定义一个辅助变量</span></span><br><span class="line">		HeroNode cur = head.next;</span><br><span class="line">		<span class="keyword">while</span>(cur!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			length++;</span><br><span class="line">			cur = cur.next;<span class="comment">//遍历</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-查找单链表中倒数第K个节点"><a href="#2-查找单链表中倒数第K个节点" class="headerlink" title="2.查找单链表中倒数第K个节点"></a>2.查找单链表中倒数第K个节点</h5><p><strong>思路</strong></p>
<ol>
<li>编写一个方法，接收head节点，同时接收一个index.</li>
<li>index表示倒数第index个节点</li>
<li>先把链表从头到尾遍历，得到链表的总长度 getLength()</li>
<li>得到size后，我们从链表第一个开始遍历(size-index)个，就可以找到</li>
<li>如果找到，则返回该节点，否则返回null</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode findLastNode(HeroNode head,<span class="keyword">int</span> index) &#123;</span><br><span class="line">		<span class="comment">//如果链表为空</span></span><br><span class="line">		<span class="keyword">if</span>(head.<span class="keyword">next</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//第一次遍历得到链表的长度</span></span><br><span class="line">		<span class="keyword">int</span> <span class="keyword">size</span> = getLength(head);</span><br><span class="line">		<span class="comment">//第二次遍历（size-index）就是倒数第几个</span></span><br><span class="line">		<span class="comment">//先做一个index的校验</span></span><br><span class="line">		<span class="keyword">if</span>(index&lt;=<span class="number">0</span> || index&gt;<span class="keyword">size</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//定义以一个辅助变量</span></span><br><span class="line">		HeroNode temp = head.<span class="keyword">next</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;(<span class="keyword">size</span>-index);i++) &#123;</span><br><span class="line">			temp = temp.<span class="keyword">next</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-单链表的反转，有难度"><a href="#3-单链表的反转，有难度" class="headerlink" title="3.单链表的反转，有难度"></a>3.单链表的反转，有难度</h5><p><strong>思路</strong></p>
<ol>
<li>先定义一个节点reverseHead = new HeroNode();</li>
<li>从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端</li>
<li>最后原来链表的head.next = reverseHead.next</li>
</ol>
<p><strong>图解</strong></p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC%E5%9B%BE%E8%A7%A3.png" alt=""></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表的反转</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversetList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//如果当前链表为空或只有一个节点，就无须翻转</span></span><br><span class="line">		<span class="keyword">if</span>(head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//创建辅助指针</span></span><br><span class="line">		HeroNode temp = head.next;</span><br><span class="line">		HeroNode next = <span class="keyword">null</span>;<span class="comment">//指向当前节点temp的下一个节点</span></span><br><span class="line">		HeroNode reserseHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line">		<span class="keyword">while</span>(temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">			next = temp.next;<span class="comment">//先暂时保留当前节点的下一个节点</span></span><br><span class="line">			temp.next = reserseHead.next;<span class="comment">//将temp的下一个节点指向新链表的最前端</span></span><br><span class="line">			reserseHead.next = temp;<span class="comment">//将temp连接到新的链表上</span></span><br><span class="line">			temp = next;<span class="comment">//让temp指向下一个节点，后移</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//将head.next指向reserseHead.next，实现单链表的反转</span></span><br><span class="line">		head.next = reserseHead.next;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h5 id="4-从尾到头打印单链表"><a href="#4-从尾到头打印单链表" class="headerlink" title="4.从尾到头打印单链表"></a>4.从尾到头打印单链表</h5><p>思路：使用栈，进行压栈，出栈从而实现从尾到头打印</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从尾到头打印单链表，使用栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;<span class="comment">//空链表无法打印</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//创建一个栈，将各个节点压栈</span></span><br><span class="line">		Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;HeroNode&gt;();</span><br><span class="line">		HeroNode cur = head.next;</span><br><span class="line">		<span class="comment">//将链表的·所有节点压栈</span></span><br><span class="line">		<span class="keyword">while</span>(cur!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			stack.push(cur);</span><br><span class="line">			cur = cur.next;<span class="comment">//后移</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将栈中的节点打印</span></span><br><span class="line">		<span class="keyword">while</span>(stack.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(stack.pop());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-合并两个有序单链表，结果仍然有序"><a href="#5-合并两个有序单链表，结果仍然有序" class="headerlink" title="5.合并两个有序单链表，结果仍然有序"></a>5.合并两个有序单链表，结果仍然有序</h5><p><strong>思路</strong></p>
<ol>
<li>分别为两条单链表创建temp1、temp2和next1，next2作用和反转单链表相同</li>
<li>创建一个新链表newlist，并创建一个temp用来指向该链表最后</li>
<li>先判断是否可以合并，不可以则返回null</li>
<li>如果可以合并，当两个链表都不为null时，也就是都还有数据时，判断大小</li>
<li>对应的next后移，temp指向判断结果temp1或2，然后temp1或2指向next1或2</li>
<li>temp后移，因为它要在最后。</li>
<li>当有一个链表遍历完后，判断谁还有数据，然后就把数据都加到新链表最后就好了。</li>
<li>最后返回合并好的链表。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleLinkedList <span class="title">mergeByOrder</span><span class="params">(HeroNode head1,HeroNode head2)</span> </span>&#123;<span class="comment">//这里顺序为从小到大</span></span><br><span class="line">		<span class="keyword">if</span>(head1.next == <span class="keyword">null</span> || head2.next == <span class="keyword">null</span>) &#123;<span class="comment">//没有数据无法合并</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		SingleLinkedList newlist = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">		HeroNode temp = newlist.getHead();<span class="comment">//使它一直指向新链表的最后</span></span><br><span class="line">		HeroNode temp1 = head1.next;<span class="comment">//先指向第一个链表</span></span><br><span class="line">		HeroNode temp2 = head2.next;<span class="comment">//先指向第二个链表</span></span><br><span class="line">		HeroNode next1 = <span class="keyword">null</span>;<span class="comment">//用来记录第一条链表的位置</span></span><br><span class="line">		HeroNode next2 = <span class="keyword">null</span>;<span class="comment">//用来记录第二条链表的位置		</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(temp1!=<span class="keyword">null</span> &amp;&amp; temp2!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(temp1.no&lt;=temp2.no) &#123;</span><br><span class="line">				next1 = temp1.next;</span><br><span class="line">				temp.next = temp1;</span><br><span class="line">				temp1 = next1;</span><br><span class="line">				</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				next2 = temp2.next;</span><br><span class="line">				temp.next = temp2;</span><br><span class="line">				temp2 = next2;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		temp.next = temp1!=<span class="keyword">null</span> ? temp1 : temp2;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> newlist;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><ul>
<li>单向链表，查找只能是一个方向，而双向链表可以向前或者向后查找</li>
<li>单向链表不能自我删除，需要靠辅助节点。而双向链表可以自我删除。</li>
</ul>
<p><strong>示意图</strong></p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p>
<h3 id="双向链表增删改查操作"><a href="#双向链表增删改查操作" class="headerlink" title="双向链表增删改查操作"></a>双向链表增删改查操作</h3><p><strong>创建节点类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义HeroNode2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode2</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> String nickname;</span><br><span class="line">	<span class="keyword">public</span> HeroNode2 next;<span class="comment">//指向下一个节点</span></span><br><span class="line">	<span class="keyword">public</span> HeroNode2 pre;<span class="comment">//指向前一个节点</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode2</span><span class="params">(<span class="keyword">int</span> no,String name,String nickName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">		<span class="keyword">this</span>.nickname=nickName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为了显示方便，重写toString</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span> + nickname + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建双向链表类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个双向链表类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span></span>&#123;</span><br><span class="line">	<span class="comment">//先初始化头结点，头结点不要动，不存放具体数据</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode2 head = <span class="keyword">new</span> HeroNode2(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode2 <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//显示链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//先判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//因为头节点不能动，需要辅助变量</span></span><br><span class="line">		HeroNode2 temp = head.next;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">//判断是否到最后</span></span><br><span class="line">			<span class="keyword">if</span>(temp==<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//输出节点的信息</span></span><br><span class="line">			System.out.println(temp);</span><br><span class="line">			<span class="comment">//将temp后移</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//默认加到最后</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//因为head节点不能动，因此需要一个辅助节点</span></span><br><span class="line">		HeroNode2 temp = head;</span><br><span class="line">		<span class="comment">//遍历链表，找到最后</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">//找到链表最后</span></span><br><span class="line">			<span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果没有找到最后，将temp后移</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当退出循环时，temp就指向了链表最后</span></span><br><span class="line">		temp.next = heroNode;</span><br><span class="line">		heroNode.pre = temp;</span><br><span class="line">		<span class="comment">//形成双向链表</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//修改</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode2 newHeroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断空</span></span><br><span class="line">		<span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空----"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//找到修改的节点，根据no</span></span><br><span class="line">		<span class="comment">//定义辅助变量</span></span><br><span class="line">		HeroNode2 temp = head.next;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//表示是否找到该节点</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//表示链表已经遍历完</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.no == newHeroNode.no) &#123;<span class="comment">//找到要修改的节点</span></span><br><span class="line">				flag=<span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//根据flag判断是否找到要修改的节点</span></span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			temp.name = newHeroNode.name;</span><br><span class="line">			temp.nickname = newHeroNode.nickname;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//没有找到</span></span><br><span class="line">			System.out.printf(<span class="string">"没有找到编号 %d 的节点，不能修改\n"</span>,newHeroNode.no);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除，对于双向链表，我们可以直接找到要删除的节点，然后自我删除！！</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空，无法删除------"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		HeroNode2 temp = head.next;<span class="comment">//这里从第一个节点开始就可以</span></span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//表示是否找到待删除的节点</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp == <span class="keyword">null</span>) &#123;<span class="comment">//已经到链表的最后</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.no == no) &#123;</span><br><span class="line">				<span class="comment">//找到待删除节点</span></span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">//后移，遍历链表</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			<span class="comment">//找到可以删除</span></span><br><span class="line">			temp.pre.next = temp.next;</span><br><span class="line">			<span class="comment">//这里有问题，如果这是最后一个节点，就不需要执行下面，否则会出现空指针异常</span></span><br><span class="line">			<span class="keyword">if</span>(temp.name!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				temp.next.pre = temp.pre;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.printf(<span class="string">"没有找到 %d 号节点，无法删除\n"</span>,no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第二种方式再添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line">	<span class="comment">//如果有这个排名。则添加失败</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//因为头结点不能动，因此通过辅助指针帮助找到添加的位置</span></span><br><span class="line">		<span class="comment">//因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">		HeroNode2 temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//标志添加的编号是否存在，默认false</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明temp在链表最后了</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.next.no &gt; heroNode.no) &#123;<span class="comment">//位置找到，就在temp后面</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no == heroNode.no) &#123;<span class="comment">//说明希望添加的heroNode的编号已然存在</span></span><br><span class="line">				flag = <span class="keyword">true</span>;<span class="comment">//说明编号存在</span></span><br><span class="line">				<span class="keyword">break</span>;				</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">//后移，遍历当前链表</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断flag的值</span></span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;<span class="comment">//说明编号存在，不能添加</span></span><br><span class="line">			System.out.printf(<span class="string">"准备插入的英雄的编号 %d 已经存在，不能加入\n"</span>,heroNode.no);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//插入到链表中，temp的后面</span></span><br><span class="line">			</span><br><span class="line">			heroNode.next = temp.next;</span><br><span class="line">			heroNode.pre = temp;</span><br><span class="line">			<span class="keyword">if</span>(temp.next!=<span class="keyword">null</span>) &#123;					</span><br><span class="line">				temp.next.pre = heroNode;				</span><br><span class="line">			&#125;</span><br><span class="line">			temp.next = heroNode;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h3><p><strong>第一种，不考虑顺序，加到最后</strong></p>
<p>这里跟单链表差不多，区别在于<strong>把最后节点的next指向加入的节点</strong>，之后把<strong>加入节点的pre指向原最后一个节点</strong>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认加到最后</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//因为head节点不能动，因此需要一个辅助节点</span></span><br><span class="line">		HeroNode2 temp = head;</span><br><span class="line">		<span class="comment">//遍历链表，找到最后</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">//找到链表最后</span></span><br><span class="line">			<span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果没有找到最后，将temp后移</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当退出循环时，temp就指向了链表最后</span></span><br><span class="line">		temp.next = heroNode;</span><br><span class="line">		heroNode.pre = temp;</span><br><span class="line">		<span class="comment">//形成双向链表</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二种，考虑顺序</strong></p>
<p>这里跟单链表思路也很像，区别在于最后。</p>
<ul>
<li>先把新加入节点的next指向temp.next</li>
<li>再把新加节点的pre指向temp</li>
<li>然后需要判断一下，是不是在最后加，即：后面还有没有节点<ul>
<li>如果是最后，判断temp.next==null，这时只需要将temp.next指向新加节点。</li>
<li>如果不是最后，在中间加，先把temp.next.pre指向新加节点，然后将temp.next指向新加节点。</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二种方式再添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line">	<span class="comment">//如果有这个排名。则添加失败</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//因为头结点不能动，因此通过辅助指针帮助找到添加的位置</span></span><br><span class="line">		<span class="comment">//因为单链表，因此我们找的temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">		HeroNode2 temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//标志添加的编号是否存在，默认false</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明temp在链表最后了</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.next.no &gt; heroNode.no) &#123;<span class="comment">//位置找到，就在temp后面</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no == heroNode.no) &#123;<span class="comment">//说明希望添加的heroNode的编号已然存在</span></span><br><span class="line">				flag = <span class="keyword">true</span>;<span class="comment">//说明编号存在</span></span><br><span class="line">				<span class="keyword">break</span>;				</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">//后移，遍历当前链表</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断flag的值</span></span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;<span class="comment">//说明编号存在，不能添加</span></span><br><span class="line">			System.out.printf(<span class="string">"准备插入的英雄的编号 %d 已经存在，不能加入\n"</span>,heroNode.no);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//插入到链表中，temp的后面</span></span><br><span class="line">			</span><br><span class="line">			heroNode.next = temp.next;</span><br><span class="line">			heroNode.pre = temp;</span><br><span class="line">			<span class="keyword">if</span>(temp.next!=<span class="keyword">null</span>) &#123;					</span><br><span class="line">				temp.next.pre = heroNode;				</span><br><span class="line">			&#125;</span><br><span class="line">			temp.next = heroNode;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a><strong>修改操作</strong></h3><p>思路跟单链表一样。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode2 newHeroNode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断空</span></span><br><span class="line">		<span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空----"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//找到修改的节点，根据no</span></span><br><span class="line">		<span class="comment">//定义辅助变量</span></span><br><span class="line">		HeroNode2 temp = head.next;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//表示是否找到该节点</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//表示链表已经遍历完</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.no == newHeroNode.no) &#123;<span class="comment">//找到要修改的节点</span></span><br><span class="line">				flag=<span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//根据flag判断是否找到要修改的节点</span></span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			temp.name = newHeroNode.name;</span><br><span class="line">			temp.nickname = newHeroNode.nickname;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//没有找到</span></span><br><span class="line">			System.out.printf(<span class="string">"没有找到编号 %d 的节点，不能修改\n"</span>,newHeroNode.no);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p><strong>思路</strong></p>
<ol>
<li>因为是双向链表，因此，我们可以实现自我删除某个节点</li>
<li>直接找到眼删除的节点</li>
<li>temp.pre.next = temp.next,这句话是把待删除前一个节点的next指向待删除的后一个节点，相当于空过了待删除节点，而连接下一个</li>
<li>temp.next.pre = temp.pre,这句话待删除节点下一个节点的pre指向待删除节点的上一个节点，相当于空过了待删除节点，而连接上一个<ul>
<li>执行temp.next.pre = temp.pre要先判断一下，是不是最后一个节点，不是删除最后一个节点才要执行！</li>
</ul>
</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除，对于双向链表，我们可以直接找到要删除的节点，然后自我删除！！</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空，无法删除------"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		HeroNode2 temp = head.next;<span class="comment">//这里从第一个节点开始就可以</span></span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//表示是否找到待删除的节点</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp == <span class="keyword">null</span>) &#123;<span class="comment">//已经到链表的最后</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.no == no) &#123;</span><br><span class="line">				<span class="comment">//找到待删除节点</span></span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;<span class="comment">//后移，遍历链表</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			<span class="comment">//找到可以删除</span></span><br><span class="line">			temp.pre.next = temp.next;</span><br><span class="line">			<span class="comment">//这里有问题，如果这是最后一个节点，就不需要执行下面，否则会出现空指针异常</span></span><br><span class="line">			<span class="keyword">if</span>(temp.name!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				temp.next.pre = temp.pre;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.printf(<span class="string">"没有找到 %d 号节点，无法删除\n"</span>,no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="显示链表"><a href="#显示链表" class="headerlink" title="显示链表"></a>显示链表</h3><p>这里跟单链表一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//先判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//因为头节点不能动，需要辅助变量</span></span><br><span class="line">		HeroNode2 temp = head.next;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">//判断是否到最后</span></span><br><span class="line">			<span class="keyword">if</span>(temp==<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//输出节点的信息</span></span><br><span class="line">			System.out.println(temp);</span><br><span class="line">			<span class="comment">//将temp后移</span></span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="环形链表与约瑟夫问题"><a href="#环形链表与约瑟夫问题" class="headerlink" title="环形链表与约瑟夫问题"></a>环形链表与约瑟夫问题</h2><h3 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h3><p>Josephu问题为：设编号为1,2,3….n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，以此类推，知道所有人出列为止，由此产生一个出队编号的序列。</p>
<p>提示：用一个不带头结点的循环链表来处理Josephu问题：先构成一个有n个节点的单向循环链表，然后由k节点起从1开始计数，计到m时，对应节点从链表中删除，然后再从被删除节点的下一个节点又从1开始计数，知道最后一个节点从链表删除算法结束。</p>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt=""></p>
<h3 id="约瑟夫问题解题思路"><a href="#约瑟夫问题解题思路" class="headerlink" title="约瑟夫问题解题思路"></a>约瑟夫问题解题思路</h3><h4 id="创建小孩节点"><a href="#创建小孩节点" class="headerlink" title="创建小孩节点"></a>创建小孩节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Boy类表示一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> no;<span class="comment">//编号</span></span><br><span class="line">	<span class="keyword">private</span> Boy next;<span class="comment">//指向下一个节点</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no=no;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> no;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.next = next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建环形链表"><a href="#创建环形链表" class="headerlink" title="创建环形链表"></a>创建环形链表</h4><ol>
<li>先创建第一个节点，让first指向该节点，并形成环形</li>
<li>后面当我们没创建一个新的节点，就把该节点，加入到已有的环形链表中即可。</li>
</ol>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9.png" alt=""></p>
<p>这是第一个节点的操作，与其他节点加入环形链表有点区别</p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E7%8E%AF%E5%BD%A2%E5%8D%95%E9%87%8F%E9%93%BE%E8%A1%A8%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5.png" alt=""></p>
<p>这是从第二个节点开始加入环形链表，由此我们可以看出first的作用是充当头指针，curBoy的作用是决定在哪里加节点。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个first节点，当前没有值</span></span><br><span class="line">	<span class="keyword">private</span> Boy first =<span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//添加小孩节点，构建成一个环形链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(nums&lt;<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"nums的值不正确"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Boy curBoy = <span class="keyword">null</span>;<span class="comment">//辅助指针，帮助构建环形链表</span></span><br><span class="line">		<span class="comment">//使用for循环来创建环形链表</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=nums;i++) &#123;</span><br><span class="line">			<span class="comment">//根据编号创建小孩节点</span></span><br><span class="line">			Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">			<span class="comment">//如果是第一个小孩</span></span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">1</span>) &#123;</span><br><span class="line">				first = boy;</span><br><span class="line">				first.setNext(first);<span class="comment">//构成环，只不过只有自己</span></span><br><span class="line">				curBoy = first;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				curBoy.setNext(boy);</span><br><span class="line">				boy.setNext(first);</span><br><span class="line">				curBoy = boy;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历环形链表"><a href="#遍历环形链表" class="headerlink" title="遍历环形链表"></a>遍历环形链表</h4><p><strong>思路</strong></p>
<ol>
<li>first节点相当于头结点，不能动，所以创建curBoy辅助节点。</li>
<li>curBoy=curBoy.next实现后移，从而遍历。</li>
<li>遍历完成条件curBoy.next == first</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历当前环形链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span>(first == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"没有任何小孩"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//因为first不能动，所以我们任然使用辅助指针完成遍历</span></span><br><span class="line">		Boy curBoy = first;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"小孩的编号 %d \n"</span>,curBoy.getNo());</span><br><span class="line">			<span class="keyword">if</span>(curBoy.getNext() == first) &#123;</span><br><span class="line">				<span class="comment">//遍历完毕</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			curBoy = curBoy.getNext();<span class="comment">//curBoy后移，实现遍历</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小孩出圈"><a href="#小孩出圈" class="headerlink" title="小孩出圈"></a>小孩出圈</h4><p><strong>思路</strong></p>
<ol>
<li>首先要让first和helper移动到对应位置<ul>
<li>helper永远在frist后面一个位置</li>
<li>因为是n个小孩中，从第k个开始报数，所以first和helper要移动k-1次</li>
</ul>
</li>
<li>小孩报数时，报m的小孩出圈，first和helper要移动m-1次</li>
<li>以上完成后，要对小孩进行出圈，使first移动到出圈小孩的下一位，然后helper.next指向first即可。</li>
</ol>
<p><strong>示意图</strong></p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%87%BA%E5%9C%88.png" alt=""></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> startNo  表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> countNum 表示数几下</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nums 表示最初有多少小孩在圈中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo,<span class="keyword">int</span> countNum,<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(first == <span class="keyword">null</span> || startNo&lt; <span class="number">1</span> || startNo&gt;nums) &#123;</span><br><span class="line">			System.out.println(<span class="string">"参数输入有误！"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//创建辅助指针，帮助完成小孩出圈，开始应该指向最后节点</span></span><br><span class="line">		Boy helper = first;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(helper.getNext() == first) &#123;<span class="comment">//说明此时已经指向最后节点</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			helper = helper.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//小孩报数前，先让first和helper移动k-1次</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;startNo-<span class="number">1</span>;j++) &#123;</span><br><span class="line">			first = first.getNext();</span><br><span class="line">			helper = helper.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//当小孩报数时，让first和helper指针同时移动countNum-1次，然后出圈</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(helper == first) &#123;<span class="comment">//说明圈中只有一个节点</span></span><br><span class="line">				<span class="keyword">break</span>;				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//让first和helper指针同时移动countNum-1次</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;countNum-<span class="number">1</span>;j++) &#123;</span><br><span class="line">				first = first.getNext();</span><br><span class="line">				helper = helper.getNext();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//此时first所指的节点就是要出圈的节点</span></span><br><span class="line">			System.out.printf(<span class="string">"小孩%d出圈\n"</span>,first.getNo());</span><br><span class="line">			first = first.getNext();<span class="comment">//让first指向下一个</span></span><br><span class="line">			helper.setNext(first);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"最后留在圈中的小孩编号%d \n"</span>,first.getNo());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="环形链表整合"><a href="#环形链表整合" class="headerlink" title="环形链表整合"></a>环形链表整合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建环形单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个first节点，当前没有值</span></span><br><span class="line">	<span class="keyword">private</span> Boy first =<span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//添加小孩节点，构建成一个环形链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(nums&lt;<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"nums的值不正确"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Boy curBoy = <span class="keyword">null</span>;<span class="comment">//辅助指针，帮助构建环形链表</span></span><br><span class="line">		<span class="comment">//使用for循环来创建环形链表</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=nums;i++) &#123;</span><br><span class="line">			<span class="comment">//根据编号创建小孩节点</span></span><br><span class="line">			Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">			<span class="comment">//如果是第一个小孩</span></span><br><span class="line">			<span class="keyword">if</span>(i==<span class="number">1</span>) &#123;</span><br><span class="line">				first = boy;</span><br><span class="line">				first.setNext(first);<span class="comment">//构成环，只不过只有自己</span></span><br><span class="line">				curBoy = first;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				curBoy.setNext(boy);</span><br><span class="line">				boy.setNext(first);</span><br><span class="line">				curBoy = boy;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//遍历当前环形链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span>(first == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"没有任何小孩"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//因为first不能动，所以我们任然使用辅助指针完成遍历</span></span><br><span class="line">		Boy curBoy = first;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"小孩的编号 %d \n"</span>,curBoy.getNo());</span><br><span class="line">			<span class="keyword">if</span>(curBoy.getNext() == first) &#123;</span><br><span class="line">				<span class="comment">//遍历完毕</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			curBoy = curBoy.getNext();<span class="comment">//curBoy后移，实现遍历</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> startNo  表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> countNum 表示数几下</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nums 表示最初有多少小孩在圈中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo,<span class="keyword">int</span> countNum,<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(first == <span class="keyword">null</span> || startNo&lt; <span class="number">1</span> || startNo&gt;nums) &#123;</span><br><span class="line">			System.out.println(<span class="string">"参数输入有误！"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//创建辅助指针，帮助完成小孩出圈，开始应该指向最后节点</span></span><br><span class="line">		Boy helper = first;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(helper.getNext() == first) &#123;<span class="comment">//说明此时已经指向最后节点</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			helper = helper.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//小孩报数前，先让first和helper移动k-1次</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;startNo-<span class="number">1</span>;j++) &#123;</span><br><span class="line">			first = first.getNext();</span><br><span class="line">			helper = helper.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//当小孩报数时，让first和helper指针同时移动countNum-1次，然后出圈</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(helper == first) &#123;<span class="comment">//说明圈中只有一个节点</span></span><br><span class="line">				<span class="keyword">break</span>;				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//让first和helper指针同时移动countNum-1次</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;countNum-<span class="number">1</span>;j++) &#123;</span><br><span class="line">				first = first.getNext();</span><br><span class="line">				helper = helper.getNext();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//此时first所指的节点就是要出圈的节点</span></span><br><span class="line">			System.out.printf(<span class="string">"小孩%d出圈\n"</span>,first.getNo());</span><br><span class="line">			first = first.getNext();<span class="comment">//让first指向下一个</span></span><br><span class="line">			helper.setNext(first);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"最后留在圈中的小孩编号%d \n"</span>,first.getNo());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Josepfu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//测试构建和遍历</span></span><br><span class="line">		CircleSingleLinkedList c = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">		c.addBoy(<span class="number">5</span>);<span class="comment">//加入五个小孩节点</span></span><br><span class="line">		c.showBoy();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//测试出圈</span></span><br><span class="line">		c.countBoy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);<span class="comment">//2,4,1,5,3</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>计算式【<code>7*5*6+9-8*6+4-3</code>】的结果。</p>
<p>请问：计算机底层如何计算得到结果的？注意不是简单地把算式列出运算，而是输入一串算式字符串直接出结果，我们要考虑数字部分和运算符，以及运算符的优先级问题等等。<strong>栈</strong>就可以解决该问题。</p>
<h2 id="栈的介绍"><a href="#栈的介绍" class="headerlink" title="栈的介绍"></a>栈的介绍</h2><ul>
<li>英文名stack</li>
<li>是一个<strong>先入后出</strong>(FILO First In Last  out)的有序列表</li>
<li>栈中元素的插入和删除只能在同一端。允许插入和删除的一端，为变化的一端，成为<strong>栈顶</strong>（top）,另一固定的一端为<strong>栈底</strong>（Bottom）</li>
</ul>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%A0%88.png" alt=""></p>
<h2 id="栈的应用场景"><a href="#栈的应用场景" class="headerlink" title="栈的应用场景"></a>栈的应用场景</h2><ol>
<li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的的程序中。</li>
<li>处理递归调用：和子程序的调用类似，知识处理存储下一个执行的地址外，也将参数、区域变量等数据存入堆栈中。</li>
<li>表达式的转换[中缀表达式转后缀表达式]与求实值。</li>
<li>二叉树的遍历。</li>
<li>图形的深度优先(depth-&gt;first)搜索法。</li>
</ol>
<h2 id="栈的快速入门"><a href="#栈的快速入门" class="headerlink" title="栈的快速入门"></a>栈的快速入门</h2><h3 id="数组实现栈"><a href="#数组实现栈" class="headerlink" title="数组实现栈"></a>数组实现栈</h3><p><strong>思路</strong></p>
<ol>
<li>定义一个top表示栈顶 初始为-1</li>
<li>入栈操作，当有数据加入栈，top++;stack[top] = data;</li>
<li>出栈操作，int value = stack[top]; top–,return value</li>
</ol>
<p><strong>示意图</strong></p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A0%88.png" alt=""></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个ArrayStack表示栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">//数组模拟栈，存放数据</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;<span class="comment">//栈顶，初始化-1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.maxSize =maxSize;</span><br><span class="line">		stack = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断栈满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top == maxSize-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断栈空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//入栈 push</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//先判断栈是否满</span></span><br><span class="line">		<span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		top++;</span><br><span class="line">		stack[top] = value;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//出栈pop</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			<span class="comment">//抛出异常</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空，没有数据"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> value = stack[top];</span><br><span class="line">		top--;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历栈,遍历时从栈顶开始显示</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"栈空没有数据"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i= top;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"stack[%d]=%d\n"</span>,i,stack[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//测试栈</span></span><br><span class="line">		ArrayStack  as = <span class="keyword">new</span> ArrayStack(<span class="number">4</span>);</span><br><span class="line">		String key = <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">boolean</span> loop = <span class="keyword">true</span>;<span class="comment">//控制是否退出</span></span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">while</span>(loop) &#123;</span><br><span class="line">			System.out.println(<span class="string">"show:表示显示栈"</span>);</span><br><span class="line">			System.out.println(<span class="string">"exit:表示退出栈"</span>);</span><br><span class="line">			System.out.println(<span class="string">"push:表示入栈"</span>);</span><br><span class="line">			System.out.println(<span class="string">"pop:表示出栈"</span>);</span><br><span class="line">			System.out.println(<span class="string">"请输出你的选择："</span>);</span><br><span class="line">			key = sc.next();</span><br><span class="line">			<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"show"</span>:</span><br><span class="line">				as.list();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">				System.out.println(<span class="string">"请输入一个数"</span>);</span><br><span class="line">				<span class="keyword">int</span> value = sc.nextInt();</span><br><span class="line">				as.push(value);</span><br><span class="line">				<span class="keyword">break</span>;	</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"pop"</span>:</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">int</span> res = as.pop();</span><br><span class="line">					System.out.printf(<span class="string">"出栈的数据是 %d\n"</span>,res);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					System.out.println(e.getMessage());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;	</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">				sc.close();</span><br><span class="line">				loop = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;	</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">					</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"程序退出！！"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表实现栈"><a href="#单链表实现栈" class="headerlink" title="单链表实现栈"></a>单链表实现栈</h3><p><strong>思路</strong></p>
<ol>
<li>链表不需要关注栈满情况。</li>
<li>head.next == null时表示栈空。</li>
<li>head.next节点表示栈顶，即：每次都在头结点后面入栈，每次也都在头结点后面出栈。</li>
</ol>
<p><strong>示意图</strong></p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%A0%88.png" alt=""></p>
<p><strong>代码实现</strong></p>
<p>先创建一个节点类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoyNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">private</span> BoyNode next;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BoyNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BoyNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> BoyNode <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(BoyNode next)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.next = next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedShack</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> BoyNode head   ;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LinkedShack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		head = <span class="keyword">new</span> BoyNode();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> BoyNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(BoyNode head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.head = head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> head.getNext() == <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(BoyNode newNode)</span> </span>&#123;		</span><br><span class="line">		</span><br><span class="line">		newNode.setNext(head.getNext());</span><br><span class="line">		head.setNext(newNode);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head.getNext()==<span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"栈空，无法出栈"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		BoyNode node = head.getNext();</span><br><span class="line">		head.setNext(head.getNext().getNext()) ; <span class="comment">//相当于head.next = head.next,next</span></span><br><span class="line">		System.out.printf(<span class="string">"出栈BoyNode:no=%d\n"</span>,node.getNo());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head.getNext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"栈空，无数据展示"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		BoyNode temp = head.getNext();</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.printf(<span class="string">"BoyNode:no=%d\n"</span>,temp.getNo());</span><br><span class="line">			temp = temp.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> BoyNode <span class="title">getTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head.getNext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空，无数据"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> head.getNext();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedStackDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		LinkedShack ls = <span class="keyword">new</span> LinkedShack();</span><br><span class="line">		BoyNode b1 = <span class="keyword">new</span> BoyNode(<span class="number">1</span>);</span><br><span class="line">		BoyNode b2 = <span class="keyword">new</span> BoyNode(<span class="number">2</span>);</span><br><span class="line">		BoyNode b3 = <span class="keyword">new</span> BoyNode(<span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">		ls.push(b1);</span><br><span class="line">		ls.push(b2);</span><br><span class="line">		ls.push(b3);</span><br><span class="line">		ls.list();</span><br><span class="line">		ls.pop();</span><br><span class="line">		ls.list();</span><br><span class="line">		System.out.println(ls.getTop().getNo());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈实现综合计算器（中缀表达式）"><a href="#栈实现综合计算器（中缀表达式）" class="headerlink" title="栈实现综合计算器（中缀表达式）"></a>栈实现综合计算器（中缀表达式）</h3><p>计算式【<code>7*2*2-5+1-5+3-3</code>】</p>
<p><strong>思路</strong></p>
<ol>
<li>分别创建数字栈和符号栈，以存放数和运算符</li>
<li>通过一个index值（索引），来遍历我们的表达式字符串</li>
<li>如果发现是一个数字，就直接入数栈。</li>
<li>如果发现扫描到的是一个符号，就分如下情况：<ol>
<li>如果发现当前符号栈为空，就直接入栈</li>
<li>如果发现当前符号栈有操作符，就进行比较<ol>
<li>当前操作符优先级如果小于或等于栈中操作符，就需要从数栈中pop两个数，从符号栈中pop一个符号，进行运算，得到结果，入数栈，然后把当前操作符入符号栈。</li>
<li>如果当前操作符优先级大于栈中操作符，则直接入符号栈。</li>
</ol>
</li>
</ol>
</li>
<li>当表达式扫描完毕，就顺序从数栈和符号栈中pop相应的数和符号，并运算。</li>
<li>最后在数栈只有一个数字，那就是表达式的结果。</li>
</ol>
<p><strong>代码实现</strong></p>
<p>首先改造一下上面数组实现栈，在里面加入几个方法：查看栈顶(peek)、返回运算符优先级(priority)、判断是不是一个运算符(isOper)和计算方法(cal)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack2</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//栈的大小</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] stack;<span class="comment">//数组模拟栈，存放数据</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;<span class="comment">//栈顶，初始化-1</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayStack2</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.maxSize =maxSize;</span><br><span class="line">		stack = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayStack2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断栈满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top == maxSize-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断栈空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//入栈 push</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//先判断栈是否满</span></span><br><span class="line">		<span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		top++;</span><br><span class="line">		stack[top] = value;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//出栈pop</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			<span class="comment">//抛出异常</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空，没有数据"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> value = stack[top];</span><br><span class="line">		top--;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历栈,遍历时从栈顶开始显示</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"栈空没有数据"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i= top;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"stack[%d]=%d\n"</span>,i,stack[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查看栈顶</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stack[top];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回运算级的优先级，优先级使用数字表示，数字越大，优先级越高</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> oper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(oper == <span class="string">'*'</span> || oper==<span class="string">'/'</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(oper == <span class="string">'+'</span> || oper == <span class="string">'-'</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//假定目前表达式只含有加减乘除</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//判断是不是一个运算符</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> val==<span class="string">'*'</span> || val==<span class="string">'/'</span> || val ==<span class="string">'+'</span> || val==<span class="string">'-'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//计算方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2 ,<span class="keyword">int</span> oper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//用于存放计算结果</span></span><br><span class="line">		<span class="keyword">switch</span> (oper) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">			res = num1 + num2;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">			res = num2 - num1;<span class="comment">//注意顺序</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">			res = num1 * num2;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">			res = num2 / num1;</span><br><span class="line">			<span class="keyword">break</span>;	</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现计算器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String expression = <span class="string">"5-2*3+1"</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建两个栈，数栈和符号栈</span></span><br><span class="line">		ArrayStack2 numStack = <span class="keyword">new</span> ArrayStack2(<span class="number">10</span>);</span><br><span class="line">		ArrayStack2 operStack = <span class="keyword">new</span> ArrayStack2(<span class="number">10</span>);</span><br><span class="line">		<span class="comment">//定义需要的相关变量</span></span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;<span class="comment">//用于扫描</span></span><br><span class="line">		<span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> oper = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">char</span> ch = <span class="string">' '</span>;<span class="comment">//每次将扫描得到的char保存到ch</span></span><br><span class="line">		String keepNum = <span class="string">""</span>;<span class="comment">//用于拼接多位数</span></span><br><span class="line">		 </span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">//一次的奥expression的每个字符</span></span><br><span class="line">			ch = expression.substring(index, index+<span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//判断ch是什么</span></span><br><span class="line">			<span class="keyword">if</span>(operStack.isOper(ch)) &#123;<span class="comment">//如果是运算符</span></span><br><span class="line">				<span class="comment">//判断当前符号栈是否为空</span></span><br><span class="line">				<span class="keyword">if</span>(!operStack.isEmpty()) &#123;</span><br><span class="line">					<span class="comment">//如果不为空</span></span><br><span class="line">					<span class="comment">/*如果当前操作符的优先级小于等于栈中操作符的优先级</span></span><br><span class="line"><span class="comment">					 * 在符号栈中pop一个符号，数栈pop两个数，进行运算，然后入数栈，然后将当前操作符如符号栈</span></span><br><span class="line"><span class="comment">					 * */</span></span><br><span class="line">					<span class="keyword">if</span>(operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;</span><br><span class="line">						num1 = numStack.pop();</span><br><span class="line">						num2 = numStack.pop();</span><br><span class="line">						oper = operStack.pop();</span><br><span class="line">						res = numStack.cal(num1, num2, oper);</span><br><span class="line">						<span class="comment">//把运算结果入数栈</span></span><br><span class="line">						numStack.push(res);</span><br><span class="line">						<span class="comment">//把操作符入符号栈</span></span><br><span class="line">						operStack.push(ch);</span><br><span class="line">					&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">//如果当前符号优先级大于栈中符号，就直接入栈</span></span><br><span class="line">						operStack.push(ch);</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//如果为空，直接加入</span></span><br><span class="line">					operStack.push(ch);				                                                                                    </span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//如果是数，则直接入数栈</span></span><br><span class="line">				<span class="comment">//numStack.push(ch-48);//'1'不是1</span></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 1.当处理多位数时，不能发现一个数就立即入栈</span></span><br><span class="line"><span class="comment">				 * 2.在处理数时，需要向表达式的index在看一位，如果是数，就继续扫描，如果是符号就入栈</span></span><br><span class="line"><span class="comment">				 * 3.因此需要定义一个字符串变量用于拼接</span></span><br><span class="line"><span class="comment">				 * */</span></span><br><span class="line">				keepNum += ch;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//如果ch已经是最后一位，直接入栈</span></span><br><span class="line">				<span class="keyword">if</span>(index == expression.length()-<span class="number">1</span>) &#123;</span><br><span class="line">					numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//判断下一个是不是数</span></span><br><span class="line">					<span class="keyword">if</span>(operStack.isOper(expression.substring(index+<span class="number">1</span>, index+<span class="number">2</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">						<span class="comment">//如果后一位是运算符，则入栈</span></span><br><span class="line">						numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">						<span class="comment">//把keepnum清空</span></span><br><span class="line">						keepNum = <span class="string">""</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//让index+1并判断是否扫描到expression最后</span></span><br><span class="line">			index++;</span><br><span class="line">			<span class="keyword">if</span>(index &gt;= expression.length()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//当表达式扫描完毕，就顺序从数栈和符号栈pop出相应的数和符号，并运算</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(operStack.isEmpty()) &#123;<span class="comment">//如果符号栈为空，计算结束，数栈中只有一个数字</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				num1 = numStack.pop();</span><br><span class="line">				num2 = numStack.pop();</span><br><span class="line">				oper = operStack.pop();</span><br><span class="line">				res = numStack.cal(num1, num2, oper);</span><br><span class="line">				<span class="comment">//把运算结果入数栈</span></span><br><span class="line">				numStack.push(res);</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> endNum = numStack.pop();</span><br><span class="line">		System.out.printf(<span class="string">"表达式 %s = %d"</span>,expression,endNum);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个代码还有有bug的，有些表达式还是会错误，有负数就不准了。 ！！￣□￣｜｜</p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h2><p>简单的说：递归就是方法自己调用自己，每次调用时传入不同的变量。递归有助于编程者解决复杂问题，同时可以让代码变得简洁。</p>
<h2 id="递归举例"><a href="#递归举例" class="headerlink" title="递归举例"></a>递归举例</h2><p><strong>打印和阶乘问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&gt;<span class="number">2</span>) &#123;</span><br><span class="line">			test(n-<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(n);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> factorial(n-<span class="number">1</span>) * n;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归能解决什么样的问题"><a href="#递归能解决什么样的问题" class="headerlink" title="递归能解决什么样的问题"></a>递归能解决什么样的问题</h2><ol>
<li>各种数学问题：8皇后问题、汉若塔、阶乘、迷宫等等</li>
<li>各种算法也使用了递归：快排，归并排序，二分查找，分治算法等等</li>
<li>将用栈解决的问题 —&gt;递归代码比较简洁</li>
</ol>
<h2 id="递归需要遵守什么样的规则"><a href="#递归需要遵守什么样的规则" class="headerlink" title="递归需要遵守什么样的规则"></a>递归需要遵守什么样的规则</h2><ol>
<li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li>
<li>方法的局部变量是独立的，不会互相影响</li>
<li>如果方法使用的是引用类型(比如数组)，就会共享该引用类型的数据</li>
<li>递归<strong>必须向退出递归的条件逼近</strong>，哦负责就是无限递归，出现StackOverflowError</li>
<li>当一个方法执行完毕或者遇到return就会返回，<strong>遵守谁调用，就将结果返回给谁</strong>，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li>
</ol>
<h2 id="迷宫回溯"><a href="#迷宫回溯" class="headerlink" title="迷宫回溯"></a>迷宫回溯</h2><p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E8%BF%B7%E5%AE%AB.png" alt=""></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//先创建一个二维数组模拟迷宫</span></span><br><span class="line">		<span class="comment">//地图</span></span><br><span class="line">		<span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">		<span class="comment">//使用1表示墙</span></span><br><span class="line">		<span class="comment">//上下全部置1</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">7</span>;i++) &#123;</span><br><span class="line">			map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">			map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//左右全部置1</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;</span><br><span class="line">			map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//设置挡板</span></span><br><span class="line">		map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		System.out.println(<span class="string">"地图的情况"</span>);</span><br><span class="line">		<span class="comment">//输出地图</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">7</span>;j++) &#123;</span><br><span class="line">				System.out.print(map[i][j]+<span class="string">" "</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用递归回溯，给小球找路</span></span><br><span class="line">		setWay(map,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//输出新的地图，小球走过后的</span></span><br><span class="line">		<span class="comment">//输出地图</span></span><br><span class="line">		System.out.println(<span class="string">"走过的地图--------------------"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">8</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">7</span>;j++) &#123;</span><br><span class="line">				System.out.print(map[i][j]+<span class="string">" "</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用递归回溯来给小球找路</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1.map表示地图</span></span><br><span class="line"><span class="comment">	 * 2.i,j表示从哪里开始出发(1,1)</span></span><br><span class="line"><span class="comment">	 * 3.如果小球能到（6,5）则说明通路找到</span></span><br><span class="line"><span class="comment">	 * 4.约定 map[i][j] = 0时表示该点没有走过，1表示墙，2表示通路可以走  3表示该位置已经走过，但是走不通</span></span><br><span class="line"><span class="comment">	 * 5.在走迷宫时需要确定一个策略：下-&gt;右-&gt;上-&gt;左，如果该点走不通，再回溯</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> map  表示地图</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i  表示那个位置</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>找到通路返回true否则false</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;<span class="comment">//说明通路已经找到</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(map[i][j] ==<span class="number">0</span>) &#123;<span class="comment">//如果当前这个点还没有走过</span></span><br><span class="line">				<span class="comment">//按照策略走</span></span><br><span class="line">				map[i][j] = <span class="number">2</span>;<span class="comment">//假定该点是可以走通的</span></span><br><span class="line">				<span class="keyword">if</span>(setWay(map, i+<span class="number">1</span>, j)) &#123;<span class="comment">//向下走，行增加1</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map, i, j+<span class="number">1</span>))&#123;<span class="comment">//向右走，列加1</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map, i-<span class="number">1</span>, j)) &#123;<span class="comment">//向上走，行-1</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map, i, j-<span class="number">1</span>)) &#123;<span class="comment">//向左走，列-1</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					map[i][j] = <span class="number">3</span>;<span class="comment">//说明该点是走不通的</span></span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;<span class="comment">//map[i][j] !=0 [1,2,3]</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">地图的情况</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line">走过的地图--------------------</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><h3 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h3><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋旗手马克斯<em>贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能相互攻击，即：任意两个皇后都不能处于*</em>同一行、同一列或同一斜线上**，问有多少种摆法(92种).</p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><ol>
<li>第一个皇后先放在第一行第一列</li>
<li>第二个皇后放在第二行第一列、然后判断是否OK,如果不OK继续放在第二行第二列….依次把所有列都放完，找到一个合适的。</li>
<li>继续放第三个皇后，还是第三行的第1,2,3….列，直到第八个皇后也能放在一个不冲突的位置，算式找到了一个正确解</li>
<li>当得到一个正确解时，在栈回退回到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解全部得到</li>
<li>然后回头继续第一个皇后放到第二列，后面继续执行1-4的步骤</li>
</ol>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题。</p>
<p>其中一维数组的下标表示第几行，对应位置的值，表示第几列。</p>
<p>例如：arr[8] = {0,4,7,5,2,6,1,3}，对应位置就是，第一行第一列、第二行第五列、第三行第八列、第四行第六列、第五行第三列、第六行第七列、第七行第二列、第八行第四列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录一下总共多少解法</span></span><br><span class="line">	<span class="comment">//先定义一个max表示共有多少个皇后</span></span><br><span class="line">	<span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line">	<span class="comment">//定义一个数组，用于保存皇后位置的结果</span></span><br><span class="line">	<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//测试一把</span></span><br><span class="line">		Queue8 queue8 = <span class="keyword">new</span> Queue8();</span><br><span class="line">		queue8.check(<span class="number">0</span>);</span><br><span class="line">		System.out.printf(<span class="string">"一共有 %d 种解法"</span>,count);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//放置第n个皇后</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n == max) &#123;<span class="comment">//说明已经放好八个</span></span><br><span class="line">			print();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//依次放入皇后，并判断是否冲突</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;max;i++) &#123;</span><br><span class="line">			<span class="comment">//先把当前皇后 ,放到该行的第一列</span></span><br><span class="line">			array[n] = i;</span><br><span class="line">			<span class="comment">//判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line">			<span class="keyword">if</span>(judeg(n)) &#123;<span class="comment">//成立说明不冲突</span></span><br><span class="line">				<span class="comment">//接着放第n+1个皇后</span></span><br><span class="line">				check(n+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查看当我们放置第n个皇后，就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n 表示第n+1个皇后</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judeg</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">			<span class="comment">//array[i] == array[n]判断是否在同一列，</span></span><br><span class="line">			<span class="comment">// Math.abs(n-i) == Math.abs(array[n]-array[i])表示判断是否在同一斜线</span></span><br><span class="line">			<span class="keyword">if</span>(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n]-array[i])) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将皇后摆放的位置打印出来</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">			System.out.print(array[i]+<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是用的穷举法，需要判断1.5W次+，效率比较低。</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="排序算法介绍"><a href="#排序算法介绍" class="headerlink" title="排序算法介绍"></a>排序算法介绍</h2><p>排序也称排序算法(Sort Algorithm)，排序是将<strong>一组数据</strong>，依<strong>指定的顺序</strong>进行<strong>排列的过程</strong>。</p>
<h2 id="排序的分类"><a href="#排序的分类" class="headerlink" title="排序的分类"></a>排序的分类</h2><ol>
<li>内部排序：指将需要处理的所有数据加载到内部存储器(内存)中进行排序。</li>
<li>外部排序：数据量过大，无法全部加载到内存中，需要借助外存(文件等)进行排序。</li>
</ol>
<h2 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h2><p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt=""></p>
<h2 id="时间复杂度与空间复杂度"><a href="#时间复杂度与空间复杂度" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h2><p><strong>时间复杂度</strong></p>
<ol>
<li>一般情况下，算法中基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)来表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数，记做：T(n) = O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。</li>
<li>T(n)不同，但时间复杂度可能相同。如：T(n) = n^2+7n+6 与 T(n) = 3n^2+2n+2 它们的T(n)不同，但时间复杂度相同，都为O(n^2)</li>
<li>计算方法<ul>
<li>用常数1代替所有加法常数 T(n)=3n^2+7n+6 —-&gt;  T(n)=3n^2+7n+1</li>
<li>修改后的函数，只保留最高阶项  T(n)=3n^2+7n+1  —-&gt;     T(n)=3n^2</li>
<li>去除最高阶项的系数         T(n)=3n^2 —-&gt;   T(n)=n^2  —&gt;  O(n^2)</li>
</ul>
</li>
</ol>
<p><strong>空间复杂度</strong></p>
<ol>
<li><p>类似于时间复杂度的讨论，一个算法的空间复杂度定义为该算法所耗费的存储空间，它也是问题规模n的函数</p>
</li>
<li><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序、基数排序就属于这种情况。</p>
</li>
<li><p>在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis,memcache)和算法本质就是用<strong>空间换时间</strong>。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2></li>
</ol>
<p>冒泡排序（Bubble Sorting） 的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）一次比较相邻元素的值，若发现逆序则交换，使值较大的元素从前向后移（从小到大排序的话），就像水底下的气泡一样逐渐往上冒。</p>
<p>优化：因为排序过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，说明此时序列已经有序。因此要在排序过程中设置一个标志flag判断在一趟排序中，有没有发生交换，从而减少不必要的比较。</p>
<p><strong>代码实现</strong></p>
<p>首先我们先一趟一趟的排序，看其中的规律</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr =  &#123;<span class="number">3</span>,<span class="number">9</span>,-<span class="number">1</span>,<span class="number">10</span>,-<span class="number">2</span>&#125;;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//为了容易理解，我们把冒泡排序的演变过程，给大家展示</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第一趟排序</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length-<span class="number">1</span>; j++) &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">					flag = <span class="keyword">true</span>;</span><br><span class="line">					temp = arr[j];</span><br><span class="line">					arr[j] =arr[j+<span class="number">1</span>];</span><br><span class="line">					arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"第一趟排序后的数组"</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length-<span class="number">1</span>-<span class="number">1</span>; j++) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">				temp = arr[j];</span><br><span class="line">				arr[j] =arr[j+<span class="number">1</span>];</span><br><span class="line">				arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"第二趟排序后的数组"</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length-<span class="number">1</span>-<span class="number">2</span>; j++) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">				temp = arr[j];</span><br><span class="line">				arr[j] =arr[j+<span class="number">1</span>];</span><br><span class="line">				arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"第三趟排序后的数组"</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length-<span class="number">1</span>-<span class="number">3</span>; j++) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">				temp = arr[j];</span><br><span class="line">				arr[j] =arr[j+<span class="number">1</span>];</span><br><span class="line">				arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"第四趟排序后的数组"</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一趟排序后的数组</span><br><span class="line">[<span class="number">3</span>, <span class="number">-1</span>, <span class="number">9</span>, <span class="number">-2</span>, <span class="number">10</span>]</span><br><span class="line">第二趟排序后的数组</span><br><span class="line">[<span class="number">-1</span>, <span class="number">3</span>, <span class="number">-2</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">第三趟排序后的数组</span><br><span class="line">[<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">第四趟排序后的数组</span><br><span class="line">[<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>这是上面代码执行的结果，我们可以看出从小到大排序，最大的值会不断后退，直到自己的位置。因为只有五个数，所以只需要排四趟，而这四趟排序的代码，我们可以看出，其实是差不多的，仅仅有一个地方不一样。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; arr.<span class="built_in">length</span><span class="number">-1</span>; <span class="built_in">j</span>++)  </span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; arr.<span class="built_in">length</span><span class="number">-1</span><span class="number">-1</span>; <span class="built_in">j</span>++)</span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; arr.<span class="built_in">length</span><span class="number">-1</span><span class="number">-2</span>; <span class="built_in">j</span>++)</span><br><span class="line"><span class="keyword">for</span> (int <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; arr.<span class="built_in">length</span><span class="number">-1</span><span class="number">-3</span>; <span class="built_in">j</span>++)</span><br></pre></td></tr></table></figure>

<p>这是四次for循环，里面只有判断条件不同，因此我们就可以在外面包一层循环来完成此时for循环，即四趟排序</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] =arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样 i 的取值是  0&lt;= i &lt; 5-1  即：0,1,2,3<br>所以内部循环判断条件变为<code>j &lt; arr.length-1-i</code>这样就完成了。</p>
<p><strong>冒泡优化</strong></p>
<p>优化方法在上面已经说明白了，假如在上面的四趟排序中，第三趟中没有发生元素交换，说明每一个元素都在自己该在的位置，即：序列已经有顺序，但是，我们上面的代码并不知道这一点，它还是会继续执行第四趟排序，虽然什么都不会做，但是白白浪费了时间。</p>
<p>优化代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装成一个方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++) &#123;			</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">					flag = <span class="keyword">true</span>;</span><br><span class="line">					temp = arr[j];</span><br><span class="line">					arr[j] =arr[j+<span class="number">1</span>];</span><br><span class="line">					arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">				&#125;				</span><br><span class="line">			&#125;			</span><br><span class="line">			<span class="keyword">if</span>(!flag) &#123;<span class="comment">//一次交换都没有发生，说明序列已经有序</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				flag = <span class="keyword">false</span>;<span class="comment">//重置flag进行下一趟的判断</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序（select sorting） 也是一种简单的排序方法，它的基本思想是：第一次从arr[0]<del>arr[n-1]中选取最小值与arr[0]交换，第二次从arr[1]</del>arr[n-1]中选取最小值，与arr[1]进行交换，第三次从arr[2]<del>arr[n-1]中选取最小值，与arr[2]进行交换……..，第i次从arr[i-1]</del>arr[n-1]选取最小值，与arr[i-1]交换，….第n-1次冲arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到从小到大排列的有序序列。</p>
<p>简单来讲就是：第一次找出最小值，与第一个元素交换位置，第二次找出次小值，与第二个元素交换位置….</p>
<p><strong>思路</strong></p>
<ol>
<li>创建一个变量存放最小值，刚开始假设第一个元素就是最小值</li>
<li>在创建一个变量存放它的位置</li>
<li>内层循环判断，当前元素是不是比最小值还小，如果是，那它就是最小值，记录它的值与位置，然后继续判断。</li>
<li>最后结束，就找到了最小值与它的位置，然后与第一个元素交换位置</li>
<li>所以第一次排序的结果为：第一个元素为最小值。</li>
<li>所以外层循环控制排序次数，第i次排序从第i个元素开始，最后结果与第i个元素交换位置</li>
<li>注意：如果我们一开始假设的最小值，恰好就是最小值，那么最后的交换位置操作就不需要做</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> minIndex =i;<span class="comment">//假定第一个是最小的</span></span><br><span class="line">		<span class="keyword">int</span> min = arr[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;j&lt;arr.length;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(min&gt;arr[j]) &#123;<span class="comment">//说明假定的最小值，并不是最小的</span></span><br><span class="line">				min = arr[j];</span><br><span class="line">				minIndex = j;</span><br><span class="line">				<span class="comment">//相当于重置最小值及位置</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//进行交换，最小值与arr[0]交换</span></span><br><span class="line">		<span class="keyword">if</span>(minIndex!=i) &#123;</span><br><span class="line">			arr[minIndex] = arr[i];</span><br><span class="line">			arr[i] = min;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"轮后"</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">排序前</span><br><span class="line">[<span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span>]</span><br><span class="line">第<span class="number">1</span>轮后</span><br><span class="line">[<span class="number">1</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">101</span>]</span><br><span class="line">第<span class="number">2</span>轮后</span><br><span class="line">[<span class="number">1</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">101</span>]</span><br><span class="line">第<span class="number">3</span>轮后</span><br><span class="line">[<span class="number">1</span>, <span class="number">34</span>, <span class="number">101</span>, <span class="number">119</span>]</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul>
<li>插入排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素适当的位置，已达到排序的目的。</li>
<li>插入排序的思想是：<strong>把n个待排序的元素看成一个有序表和一个无序表</strong>，开始时，有序表中只包含一个元素，无序表n-1个元素，排序过程中每次从无序表中取出第一个元素，从它往前，依次与有序表元素进行比较，将他插入到有序表中的适当位置，是指成为新的有序表。</li>
</ul>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png" alt=""></p>
<p><strong>代码实现</strong></p>
<p>思路：</p>
<ol>
<li>因为第一个元素默认在有序表中，所从第二个元素开始，往前判断，找到它的位置</li>
<li>先把它用一个变量存起来，并且用一个变量记录索引从哪开始往前判断</li>
<li>假设这里是从小到大排序，如果当前这个数，比它前面的数小，那么它应该向前移动</li>
<li>这里使用前面的元素向后覆盖，已达到向前移动的效果。（因为我已将找位置的元素保存起来了）</li>
<li>索引在移动一个元素后要–，因为要比较前一个到前n个，索引还要&gt;=0,防止越界</li>
<li>通过上面的循环判断并移动覆盖，最后记录索引的变量的值，就是要插入位置的前一个位置。因为要插入的数要比它前面的数小，而循环结束时，要插入的数比它前面的数大了，所以结束，但这时索引变量指向要插入位置的前面。</li>
<li>进行赋值操作<code>arr[insertIndex + 1] = insertVal</code></li>
<li>以上是一次排序，因此需要外层循环，从第二个元素开始，到最后，都要去找他们自己的位置</li>
<li>所以外层<code>for(int i = 1;i&lt;arr.length;i++)</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> insertVal = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> insertIndex=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			insertVal = arr[i];</span><br><span class="line">			insertIndex = i-<span class="number">1</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>(insertIndex&gt;=<span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">				arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">				insertIndex--;</span><br><span class="line">			&#125;</span><br><span class="line">			arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">			System.out.println(<span class="string">"第"</span>+i+<span class="string">"轮后"</span>);</span><br><span class="line">			System.out.println(Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="简单插入排序可能存在的问题"><a href="#简单插入排序可能存在的问题" class="headerlink" title="简单插入排序可能存在的问题"></a>简单插入排序可能存在的问题</h3><p>数组arr=[2,3,4,5,6,1]这时需要插入的数 1 最小，那么它前面的2,3,4,5,6都需要往后移一位。</p>
<p>结论：当<strong>插入的数较小</strong>时（这里指从小到大排序），<strong>后移次数明显增多</strong>，效率会降低</p>
<h3 id="希尔排序介绍"><a href="#希尔排序介绍" class="headerlink" title="希尔排序介绍"></a>希尔排序介绍</h3><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种<strong>插入排序</strong>，它是简单插入排序经过改进之后的一个<strong>更高效的版本</strong>，也称为<strong>缩小增量排序</strong>。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量追歼减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h3 id="希尔排序示意图"><a href="#希尔排序示意图" class="headerlink" title="希尔排序示意图"></a>希尔排序示意图</h3><p>注意这个图是偶数个元素，让人容易认为两两一组，这里说一下奇数个元素，其实分组是根据步长来分的，只要你走过这个步长，还有元素那么你们就是一组，这可以根据下面第二轮步长为2可以看出，往后数1,2只要有2你们就是一组，从3开始1,2报数，报2的就为一组。</p>
<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.png" style="zoom: 80%;" />

<h3 id="希尔排序——交换法实现"><a href="#希尔排序——交换法实现" class="headerlink" title="希尔排序——交换法实现"></a>希尔排序——交换法实现</h3><p>首先方便理解，我们先一步一步去分析它的排序步骤</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line">		</span><br><span class="line">		shellSortStep(arr);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//先一步一步分析</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSortStep</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//希尔排序第一轮</span></span><br><span class="line">	    <span class="comment">//因为第一轮排序，是将10个数据分成了五组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">5</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			<span class="comment">//遍历各组中，所有的元素，共有五组，每组有两个元素，步长是5</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j= i-<span class="number">5</span> ;j&gt;=<span class="number">0</span>;j-=<span class="number">5</span>) &#123;</span><br><span class="line">				<span class="comment">//如果当前这个元素，大于 加上步长后的那个元素 ，说明交换（从小到大排序）</span></span><br><span class="line">				<span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">5</span>]) &#123;</span><br><span class="line">					temp = arr[j];</span><br><span class="line">					arr[j] = arr[j+<span class="number">5</span>];</span><br><span class="line">					arr[j+<span class="number">5</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"希尔排序一轮后="</span>+ Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//希尔排序第2轮</span></span><br><span class="line">	    <span class="comment">//因为第2轮排序，五组/2=2组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			<span class="comment">//遍历各组中，所有的元素，共有五组，每组有两个元素，步长是5</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j= i-<span class="number">2</span> ;j&gt;=<span class="number">0</span>;j-=<span class="number">2</span>) &#123;</span><br><span class="line">				<span class="comment">//如果当前这个元素，大于 加上步长后的那个元素 ，说明交换（从小到大排序）</span></span><br><span class="line">				<span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">2</span>]) &#123;</span><br><span class="line">					temp = arr[j];</span><br><span class="line">					arr[j] = arr[j+<span class="number">2</span>];</span><br><span class="line">					arr[j+<span class="number">2</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"希尔排序二轮后="</span>+ Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//希尔排序第3轮</span></span><br><span class="line">	    <span class="comment">//因为第3轮排序，2/2=1</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			<span class="comment">//遍历各组中，所有的元素，共有五组，每组有两个元素，步长是5</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j= i-<span class="number">1</span> ;j&gt;=<span class="number">0</span>;j-=<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">//如果当前这个元素，大于 加上步长后的那个元素 ，说明交换（从小到大排序）</span></span><br><span class="line">				<span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">					temp = arr[j];</span><br><span class="line">					arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">					arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"希尔排序三轮后="</span>+ Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">希尔排序一轮后=[<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>]</span><br><span class="line">希尔排序二轮后=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>]</span><br><span class="line">希尔排序三轮后=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p><strong>交换法整合</strong></p>
<p>思路：这里其实就是根据步长去分组，然后在各个组内进行交换排序，由于元素交换也是要耗费时间的，所以交换法实现希尔排序效率较低</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> gap = arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = gap;i&lt;arr.length;i++) &#123;</span><br><span class="line">				<span class="comment">//遍历各组中，所有的元素，共有gap组，每组有n个元素，步长是gap</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j= i-gap ;j&gt;=<span class="number">0</span>;j-=gap) &#123;</span><br><span class="line">					<span class="comment">//如果当前这个元素，大于 加上步长后的那个元素 ，说明交换（从小到大排序）</span></span><br><span class="line">					<span class="keyword">if</span>(arr[j] &gt; arr[j+gap]) &#123;</span><br><span class="line">						temp = arr[j];</span><br><span class="line">						arr[j] = arr[j+gap];</span><br><span class="line">						arr[j+gap] = temp;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序——移位法实现"><a href="#希尔排序——移位法实现" class="headerlink" title="希尔排序——移位法实现"></a>希尔排序——移位法实现</h3><p>说明：这里根据步长分组后要进行插入，其实这里是每个组按顺序一步一步来，不是说先把第一组全都插入排序完，然后第二组，第三组，不是这样的。</p>
<p>插入排序前面讲过了，从第二个开始往前比较，这里就是从每组的第二个开始往各组前面得元素比较。</p>
<p>先是第一组第二个，然后第二组第二个…第n组第二个；动作都是往前插入</p>
<p>然后第一组第三个，第二组第三个…第n组第三个；</p>
<p>….</p>
<p>第一组第n个，第二组第n个…第n组第n个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> gap = arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//从第gap个元素,逐个对其所在的组进行直接插入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap;i&lt;arr.length;i++) &#123;</span><br><span class="line">            j = i;<span class="comment">//保存当前但插入元素的位置</span></span><br><span class="line">            temp = arr[j];<span class="comment">//保存当前待插入元素的值</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt;arr[j - gap]) &#123;</span><br><span class="line">                <span class="keyword">while</span>(j - gap &gt;=<span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap])&#123;</span><br><span class="line">                    <span class="comment">//移动</span></span><br><span class="line">                    arr[j] = arr[j - gap];</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当退出while循环后，就给temp找到了插入的位置</span></span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是对<strong>冒泡排序</strong>的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后在按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，一次大袋整个数据变成有序序列。</p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" alt=""></p>
<p><strong>代码实现</strong></p>
<p>思路说明：</p>
<ol>
<li><p>首先记录初始的左下标，右下标，并记录中间值，创建temp临时变量用于交换数据</p>
</li>
<li><p>因为左右指针都往中间靠拢，所以进入循环的条件就是左指针&lt; 右指针</p>
</li>
<li><p>循环开始，首先在左边找到一个大于或等于中值的数，如果左边都小于中值，那么找到的就会是中值本身。</p>
</li>
<li><p>然后在右边找到一个小于或等于中值的数，如果右边都大于中值，那么找到的就会是中值本身。</p>
</li>
<li><p>找到这两个数以后，我要判断一下，你们找的是不是都是中值，也就是左指针和右指针都在中值上</p>
<ol>
<li>如果都在中值上，就说明左边全部小于中值，右边全部大于中值，此时结束循环。</li>
<li>如果不是，那么我就要进行交换，交换找到的两个元素的位置</li>
<li>交换完毕后，我还要判断一下，你们左右指针所找到的这两个数，虽然不是中值本身，但有没有可能是和中值相等，如果和中值想等的话，那我下次循环继续往下找的时候，那找到的就都是你们了，死循环在这里了</li>
<li>所以如果有和中值相等的，如果左指针指向的数等于中值，那就往左移一位，同理右指针如果等于中值，那就往右移一位<ul>
<li>其实这里移位的时候左右两个指针都等于中值，然后两边都移位就可以，但这样写问题也不大</li>
</ul>
</li>
</ol>
</li>
<li><p>以上做完后，是一轮排序，此时还需判断，这时候左右指针是不是相等，如果相等则要把他们错开。</p>
</li>
<li><p>向左向右递归进行</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;-<span class="number">9</span>,<span class="number">78</span>,<span class="number">0</span>,<span class="number">23</span>,-<span class="number">567</span>,<span class="number">70</span>&#125;;</span><br><span class="line">		quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">"arr="</span>+Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> l = left;<span class="comment">//左下标</span></span><br><span class="line">		<span class="keyword">int</span> r = right;<span class="comment">//右下标</span></span><br><span class="line">		<span class="keyword">int</span> pivot = arr[(left+right) / <span class="number">2</span>];<span class="comment">//中轴值</span></span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//临时变量，交换时使用</span></span><br><span class="line">		<span class="comment">//while循环的目的，是比pivot小的，放到它的左边，比pivot大的放到右边（从小到大排序）</span></span><br><span class="line">		<span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">			<span class="comment">//在pivot左边一直找，找到一个大于或者等于pivot的值，才退出</span></span><br><span class="line">			<span class="keyword">while</span>(arr[l] &lt; pivot) &#123;</span><br><span class="line">				l+=<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//从右边一直找，找一个小于或等于pivot的值</span></span><br><span class="line">			<span class="keyword">while</span>(arr[r] &gt; pivot) &#123;</span><br><span class="line">				r--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果l&gt;=r成立，说明pivot左右两边的值，已经按照，左边全部小于等于pivot，右边全部大于等于pivot</span></span><br><span class="line">			<span class="keyword">if</span>(l &gt;= r) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			temp = arr[l];</span><br><span class="line">			arr[l] = arr[r];</span><br><span class="line">			arr[r] = temp;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//如果交换完后，发现arr[l] = pivot值,r--，前移,如果不移动，就会一直找这个数了。</span></span><br><span class="line">			<span class="keyword">if</span>(arr[l] == pivot) &#123;</span><br><span class="line">				r--;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//如果交换完后，发现arr[r] = pivot值,l++，后移</span></span><br><span class="line">			<span class="keyword">if</span>(arr[r] == pivot) &#123;</span><br><span class="line">				l++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//如果 l==r 必须l++,r--否则会栈溢出</span></span><br><span class="line">		<span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">			l++;</span><br><span class="line">			r--;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//向左递归</span></span><br><span class="line">		<span class="keyword">if</span>(left &lt; r) &#123;</span><br><span class="line">			quickSort(arr, left, r);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//向右递归</span></span><br><span class="line">		<span class="keyword">if</span>(right&gt;l) &#123;</span><br><span class="line">			quickSort(arr, l, right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序是利用归并的思想实现的排序方法，该算法采用经典的<strong>分治策略</strong>。（分治法将温蒂分成一些小问题然后递归求解，而治阶段姿势将分的阶段得到的各答案“修补”在一起，即分而治之）</p>
<h3 id="归并排序思想示意图1"><a href="#归并排序思想示意图1" class="headerlink" title="归并排序思想示意图1"></a>归并排序思想示意图1</h3><p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%88%86%E6%B2%BB.png" alt=""></p>
<h3 id="归并排序思想示意图2–合并相邻有序子序列"><a href="#归并排序思想示意图2–合并相邻有序子序列" class="headerlink" title="归并排序思想示意图2–合并相邻有序子序列"></a>归并排序思想示意图2–合并相邻有序子序列</h3><p>我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看一下实现步骤</p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%90%88%E5%B9%B6%E7%9B%B8%E9%82%BB%E5%AD%90%E5%BA%8F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>首先我们要先写一个合并代码，因为分治中，分其实没做什么事情，就是把它们分开，重要的是治。</p>
<h4 id="合并方法"><a href="#合并方法" class="headerlink" title="合并方法"></a>合并方法</h4><p><strong>思路</strong>：</p>
<ol>
<li><p>首先要确定，我们所传入的参数。</p>
<ul>
<li>待排序数组arr是肯定要传入的。</li>
<li>左边序列的初始索引 left</li>
<li>中间索引 mid,这个参数是因为，要确定右边序列的初始索引，mid+1，和左边序列的最后mid</li>
<li>右边索引 right 右边序列的最后</li>
<li>还要有临时数组temp，所以归并排序是比较耗空间的。</li>
</ul>
</li>
<li><p>创建临时变量 t 表示temp的当前位置，因为后面要往temp里放元素</p>
</li>
<li><p>创建变量i = left用于记录左边初始索引，j=mid+1用于记录右边初始索引</p>
</li>
<li><p>然后就要把左右两个序列的值，放到temp中</p>
<ol>
<li>应该是左边第一个元素与右边第一个元素比较，如果左边小于等于右边，那么左边进temp(这里规定从小到大排序)。</li>
<li>这时左边序列第一个元素处理完毕后，左边索引要后移，i++;同时temp也要后移一位t++;</li>
<li>反之，左边大于右边，就把右边放入temp，j++;t++</li>
<li>循环结束的条件就是其中一组序列，没数据了，即：i&gt;mid说明左边没了，j&gt;right说明右边没了</li>
</ol>
</li>
<li><p>这时候我们还要把其中还有剩余数据的序列中的数据依次加入temp(因为序列本身有序)</p>
</li>
<li><p>最后全部放到temp后，要把temp中的数据copy到原数组arr的对应位置</p>
<ol>
<li><p>先令t =0;使其回到temp序列的最头上</p>
</li>
<li><p>然后在 left到right范围内，将temp的值赋给arr</p>
<p><strong>注意</strong>：这里的copy操作一定要好好理解一下，结合上方示意图，并不是每次都copy整个数组，最后才是copy的整个数组。</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并方法</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr 待排序数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mid 中间索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> temp 做中转的数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid, <span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = left;<span class="comment">// 初始化 i ，有序序列的初始索引</span></span><br><span class="line">		<span class="keyword">int</span> j = mid+<span class="number">1</span>;<span class="comment">//因为除以二是在右边索引的前一个位置，所以+1   右边有序序列的初始索引</span></span><br><span class="line">		<span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//t是指向temp数组的当前索引</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//《一》</span></span><br><span class="line">		<span class="comment">//先把左右两边(已经有序)的数据，按照规则填充到temp数组</span></span><br><span class="line">		<span class="comment">//直到左右两边的有序序列，有一方处理完毕为止。</span></span><br><span class="line">		<span class="keyword">while</span>(i &lt;=mid &amp;&amp; j&lt;=right) &#123;<span class="comment">//继续</span></span><br><span class="line">			<span class="keyword">if</span>(arr[i]&lt;=arr[j]) &#123; <span class="comment">//左边小于右边</span></span><br><span class="line">				<span class="comment">//把左边放入temp，temp当前位置后移一位，左边序列也后移一位</span></span><br><span class="line">				temp[t] = arr[i];				</span><br><span class="line">				i++;</span><br><span class="line">				t++;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				temp[t] = arr[j];</span><br><span class="line">				j++;</span><br><span class="line">				t++;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//&lt;二&gt;</span></span><br><span class="line">		<span class="comment">//把有剩余数据的一边的数据一次全部填充到temp</span></span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid) &#123;<span class="comment">//说明左边的有序序列还有剩余，就全部填充到temp</span></span><br><span class="line">			temp[t] = arr[i];</span><br><span class="line">			t++;</span><br><span class="line">			i++;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;=right) &#123;<span class="comment">//说明有边的有序序列还有剩余，就全部填充到temp</span></span><br><span class="line">			temp[t] = arr[j];</span><br><span class="line">			t++;</span><br><span class="line">			j++;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//&lt;三&gt;</span></span><br><span class="line">		<span class="comment">//将temp数组中的元素拷贝到arr</span></span><br><span class="line">		<span class="comment">//并不是每次都拷贝所有的</span></span><br><span class="line">		t=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> tempLeft = left;<span class="comment">//</span></span><br><span class="line">		<span class="keyword">while</span>(tempLeft &lt;= right) &#123; <span class="comment">//第一次合并，tempLeft= 0 ，right= 1</span></span><br><span class="line">			arr[tempLeft] = temp[t];</span><br><span class="line">			t += <span class="number">1</span>;</span><br><span class="line">			tempLeft+=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分-合"><a href="#分-合" class="headerlink" title="分+合"></a>分+合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分+合</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line">			<span class="comment">//向左递归进行分解</span></span><br><span class="line">			mergeSort(arr, left, mid, temp);</span><br><span class="line">			<span class="comment">//向右递归</span></span><br><span class="line">			mergeSort(arr, mid+<span class="number">1</span>, right, temp);</span><br><span class="line">			<span class="comment">//到合并</span></span><br><span class="line">			merge(arr,left,mid,right,temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这里其实通过上方示意图1也能看出，我先进行左递归，也就是分解左边，等分到最后，分不动了。然后我又去分解右边，等右边也分不动了，就开始合并。</p>
<p><strong>也就是最后分完的，最先合并，因为递归要压栈。</strong></p>
<p>这里的过程还是比较难理解的，最好debug看一下，可以加深理解。</p>
<p>最后测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> arr[] = &#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];<span class="comment">//临时数组</span></span><br><span class="line">		mergeSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,temp);</span><br><span class="line">		System.out.println(<span class="string">"归并排序后="</span>+Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ol>
<li>基数排序（radixSort）属于“分配式排序”，又称“桶子法”。顾名思义，他是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</li>
<li>基数排序是属于稳定的排序，基数排序法是效率高的稳定性排序法</li>
<li>基数排序是桶排序的扩展</li>
<li>基数排序是1887年赫尔曼.何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。</li>
</ol>
<h3 id="基数排序的基本思想"><a href="#基数排序的基本思想" class="headerlink" title="基数排序的基本思想"></a>基数排序的基本思想</h3><p>将所有带比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行依次排序。这样从最低位排序一直到最高位排序完成后，数列就变成立一个有序序列。</p>
<h3 id="基数排序示意图"><a href="#基数排序示意图" class="headerlink" title="基数排序示意图"></a>基数排序示意图</h3><p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F1-2.png" alt=""></p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F3.png" alt=""></p>
<h3 id="基数排序代码实现"><a href="#基数排序代码实现" class="headerlink" title="基数排序代码实现"></a>基数排序代码实现</h3><p>测试数组：<code>int arr[] = {53,3,542,748,14,214};</code></p>
<p>首先按步骤一步一步来演示</p>
<p><strong>步骤说明</strong></p>
<ol>
<li>首先我们要创建桶，0-9一共十个桶，这样用十个一维数组来表示。桶的大小，为了防止溢出，只能是数组的长度了，咱也没办法，万一数据的某一位都是一个数呢！</li>
<li>创建一个数组，用于记录每个桶内有效数据个数</li>
<li>然后我们就可以开始遍历整个数组，取出对应位数的元素，然后放到对应的桶中，对应有效数据+1</li>
<li>遍历完成后就可以按照桶的顺序，从桶里面把数据拿出来放到原数组中<ol>
<li>这时，先定义index=0用于记录原数组的第几个元素</li>
<li>不断取出数据放到index所指向的位置</li>
<li>每放一个，index就+1</li>
<li>其中当一个桶中的有效数据都拿出来后，我们要把记录有效数据的值变为0，因为下一轮还需要它来统计</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSortStep</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第一轮（针对个位）</span></span><br><span class="line">		<span class="comment">//定义一个二维数组，表示十个桶，每个桶就是一个一维数组</span></span><br><span class="line">		<span class="comment">/*二维数组包含十个一维数组，为了防止在数的时候数据溢出，我们每个一维数组（桶）大小定为arr.length</span></span><br><span class="line"><span class="comment">		 * 明显基数排序是使用空间换时间的经典算法</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		<span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">		<span class="comment">//为了记录每个桶中实际存放了多少个数据，我们定义一个一维数组来记录各个桶每次放入的数据个数</span></span><br><span class="line">		<span class="keyword">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;arr.length;j++) &#123;</span><br><span class="line">			<span class="comment">//取出每个元素的个位</span></span><br><span class="line">			<span class="keyword">int</span> digitOfElement = arr[j] % <span class="number">10</span>;</span><br><span class="line">			<span class="comment">//放到对应的桶中</span></span><br><span class="line">			bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">			bucketElementCounts[digitOfElement]++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//按照桶的顺序，取出来</span></span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//遍历每一个桶</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k= <span class="number">0</span>;k&lt;bucket.length;k++) &#123;</span><br><span class="line">			<span class="comment">//如果桶中有数据，我们才放入原数组</span></span><br><span class="line">			<span class="keyword">if</span>(bucketElementCounts[k] != <span class="number">0</span> ) &#123;</span><br><span class="line">				<span class="comment">//循环该桶，即第k个桶，即第k个一维数组</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>;l&lt;bucketElementCounts[k];l++) &#123;</span><br><span class="line">					<span class="comment">//取出元素，放入到arr</span></span><br><span class="line">					arr[index] = bucket[k][l];</span><br><span class="line">					index++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//用完后置零bucketElementCounts[k]=0，有效个数下一轮要重新统计</span></span><br><span class="line">			bucketElementCounts[k]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"第一轮，对位的排序处理 arr="</span>+Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第二轮*****************************************************************************</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;arr.length;j++) &#123;</span><br><span class="line">			<span class="comment">//取出每个元素的个位</span></span><br><span class="line">			<span class="keyword">int</span> digitOfElement = arr[j] /<span class="number">10</span> % <span class="number">10</span>;</span><br><span class="line">			<span class="comment">//放到对应的桶中</span></span><br><span class="line">			bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">			bucketElementCounts[digitOfElement]++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//按照桶的顺序，取出来</span></span><br><span class="line">		index = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//遍历每一个桶</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k= <span class="number">0</span>;k&lt;bucket.length;k++) &#123;</span><br><span class="line">			<span class="comment">//如果桶中有数据，我们才放入原数组</span></span><br><span class="line">			<span class="keyword">if</span>(bucketElementCounts[k] != <span class="number">0</span> ) &#123;</span><br><span class="line">				<span class="comment">//循环该桶，即第k个桶，即第k个一维数组</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>;l&lt;bucketElementCounts[k];l++) &#123;</span><br><span class="line">					<span class="comment">//取出元素，放入到arr</span></span><br><span class="line">					arr[index] = bucket[k][l];</span><br><span class="line">					index++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			bucketElementCounts[k]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"第二轮，对十位的排序处理 arr="</span>+Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第三轮*****************************************************************************</span></span><br><span class="line">		</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;arr.length;j++) &#123;</span><br><span class="line">				<span class="comment">//取出每个元素的个位</span></span><br><span class="line">				<span class="keyword">int</span> digitOfElement = arr[j] /<span class="number">100</span> % <span class="number">10</span>;</span><br><span class="line">				<span class="comment">//放到对应的桶中</span></span><br><span class="line">				bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">				bucketElementCounts[digitOfElement]++;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//按照桶的顺序，取出来</span></span><br><span class="line">			index = <span class="number">0</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//遍历每一个桶</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k= <span class="number">0</span>;k&lt;bucket.length;k++) &#123;</span><br><span class="line">				<span class="comment">//如果桶中有数据，我们才放入原数组</span></span><br><span class="line">				<span class="keyword">if</span>(bucketElementCounts[k] != <span class="number">0</span> ) &#123;</span><br><span class="line">					<span class="comment">//循环该桶，即第k个桶，即第k个一维数组</span></span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>;l&lt;bucketElementCounts[k];l++) &#123;</span><br><span class="line">						<span class="comment">//取出元素，放入到arr</span></span><br><span class="line">						arr[index] = bucket[k][l];</span><br><span class="line">						index++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				bucketElementCounts[k]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"第三轮，对百位的排序处理 arr="</span>+Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发现规律从而整合</strong></p>
<p>思路：这里我们从上面发现，排序次数与最大值的位数有关，所以我们先求出最大值的位数，用它来确定外层循环的次数。然后在取余时加一个变量n，每次循环n都乘以10，这样元素/n%10就能做到，第一轮取个位，第二轮取十位，以此类推。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//先得到数组中最大数的位数</span></span><br><span class="line">		<span class="keyword">int</span> max = arr[<span class="number">0</span>];<span class="comment">//假设第一个数就是最大数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i]&gt;max) &#123;</span><br><span class="line">				max=arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//得到最大数是几位数</span></span><br><span class="line">		<span class="keyword">int</span> maxLength=(max+<span class="string">""</span>).length();</span><br><span class="line">		<span class="comment">//十个桶</span></span><br><span class="line">		<span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">		<span class="comment">//为了记录每个桶中实际存放了多少个数据，我们定义一个一维数组来记录各个桶每次放入的数据个数</span></span><br><span class="line">		<span class="keyword">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//使用循环</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,n=<span class="number">1</span>;i&lt;maxLength;i++,n*=<span class="number">10</span>) &#123;	</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;arr.length;j++) &#123;</span><br><span class="line">				<span class="comment">//取出每个元素的个位</span></span><br><span class="line">				<span class="keyword">int</span> digitOfElement = arr[j] /n % <span class="number">10</span>;</span><br><span class="line">				<span class="comment">//放到对应的桶中</span></span><br><span class="line">				bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">				bucketElementCounts[digitOfElement]++;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//按照桶的顺序，取出来</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//遍历每一个桶</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k= <span class="number">0</span>;k&lt;bucket.length;k++) &#123;</span><br><span class="line">				<span class="comment">//如果桶中有数据，我们才放入原数组</span></span><br><span class="line">				<span class="keyword">if</span>(bucketElementCounts[k] != <span class="number">0</span> ) &#123;</span><br><span class="line">					<span class="comment">//循环该桶，即第k个桶，即第k个一维数组</span></span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>;l&lt;bucketElementCounts[k];l++) &#123;</span><br><span class="line">						<span class="comment">//取出元素，放入到arr</span></span><br><span class="line">						arr[index] = bucket[k][l];</span><br><span class="line">						index++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//用完后置零bucketElementCounts[k]=0，有效个数下一轮要重新统计</span></span><br><span class="line">				bucketElementCounts[k]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			index = <span class="number">0</span>;</span><br><span class="line">			System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"轮，对位的排序处理 arr="</span>+Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基数排序说明"><a href="#基数排序说明" class="headerlink" title="基数排序说明"></a>基数排序说明</h3><ol>
<li>基数排序是对传统排序的扩展，速度很快。</li>
<li>技术排序是经典的空间换时间的方式，占用内存很大，当对海量数据排序时，容易造成OutOfMenoryError</li>
<li>基数排序是稳定的【稳定的意思是，原来的数比后面的数小，那么操作之后，它们谁在前谁在后还是不变】</li>
<li>有负数的数组，我们不用基数排序来排序，如果要支持负数，我的思路时，找出最小值负数，所有的数都减去这个数，这样序列就都变为正了，最后怕排序完，所有的数再加上这个负数。</li>
</ol>
<h2 id="常用排序算法总结和对比"><a href="#常用排序算法总结和对比" class="headerlink" title="常用排序算法总结和对比"></a>常用排序算法总结和对比</h2><p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%BE%E6%AF%94%E8%BE%83.png" alt=""></p>
<p><strong>相关术语解释</strong></p>
<ol>
<li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b前面</li>
<li>内排序：所有排序操作都在内存中完成</li>
<li>外排序：数据量巨大，把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行</li>
<li>时间复杂度：算法执行所耗费的时间</li>
<li>空间复杂度：运行完一个程序所需内存的大小</li>
<li>n:数据规模</li>
<li>k:“桶”的个数</li>
<li>In-place:不占用额外内存</li>
<li>Out-place:占用额外内存</li>
</ol>
<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><h2 id="查找算法介绍"><a href="#查找算法介绍" class="headerlink" title="查找算法介绍"></a>查找算法介绍</h2><p>在Java中，我们常用的查找算法有四种：</p>
<ol>
<li>顺序查找</li>
<li>二分查找/折半查找</li>
<li>差值查找</li>
<li>斐波那契查找</li>
</ol>
<h2 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h2><p>废话不多说，直接上代码，这里找到就返回位置，找不到返回-1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[i]==value) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ol>
<li>首先二分查找的前提是：序列有序，从小到大或从大到小</li>
<li>以从小到大为例：二分查找先从中间开始找，如果中间值大于要找的值，说明要找的值位于左边，反之，位于右边</li>
<li>然后不断重复查找过程，直到找到或找不到</li>
</ol>
<p><strong>代码1</strong></p>
<p>这里找到就返回，也就是说就算有重复的，那么也只能返回一个值的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left 左边索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> findVal 要查找的值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 如果找到，返回下标。找不到返回-1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binartSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//从小到大排序的序列中找</span></span><br><span class="line">		<span class="comment">//当left&gt;right时，说明递归整个数组，但是没有找到</span></span><br><span class="line">		<span class="keyword">if</span>(left&gt;right) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) /<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> midValue=arr[mid];</span><br><span class="line">		<span class="keyword">if</span>(findVal &gt; midValue) &#123;<span class="comment">//向右递归</span></span><br><span class="line">			<span class="keyword">return</span> binartSearch(arr, mid+<span class="number">1</span>, right, findVal);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(findVal &lt; midValue)&#123;<span class="comment">//向左递归</span></span><br><span class="line">			<span class="keyword">return</span> binartSearch(arr, left, mid-<span class="number">1</span>, findVal);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码2</strong></p>
<p>这里要把所有满足条件的位置都找出来，放到集合中，返回集合。没有就返回空集合</p>
<p>思路：</p>
<p>在上面代码找到的基础上，向两边判断，是不是跟我这个值一样，如果一样加入集合。</p>
<p>因为二分法，从中间开始找，所以位于中间的数，肯定先被找到。又因为序列有序，所以符合条件的值是连续的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title">binartSearch2</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//从小到大排序的序列中找</span></span><br><span class="line">		<span class="comment">//当left&gt;right时，说明递归整个数组，但是没有找到</span></span><br><span class="line">		<span class="keyword">if</span>(left&gt;right) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = (left + right) /<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> midValue=arr[mid];</span><br><span class="line">		<span class="keyword">if</span>(findVal &gt; midValue) &#123;<span class="comment">//向右递归</span></span><br><span class="line">			<span class="keyword">return</span> binartSearch2(arr, mid+<span class="number">1</span>, right, findVal);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(findVal &lt; midValue)&#123;<span class="comment">//向左递归</span></span><br><span class="line">			<span class="keyword">return</span> binartSearch2(arr, left, mid-<span class="number">1</span>, findVal);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			ArrayList&lt;Integer&gt; resIndexlist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">			<span class="keyword">int</span> temp = mid-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(temp&lt;<span class="number">0</span> || arr[temp]!=findVal) &#123;<span class="comment">//找到最前面，或者找到不是findVal就可以退出了</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				resIndexlist.add(temp);</span><br><span class="line">				temp-=<span class="number">1</span>;<span class="comment">//temp左移，继续寻找</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//别忘了把中间的放进去</span></span><br><span class="line">			resIndexlist.add(mid);</span><br><span class="line">			<span class="comment">//向右边扫描</span></span><br><span class="line">			temp = mid+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(temp&gt;arr.length || arr[temp]!=findVal ) &#123;<span class="comment">//向右找到最后，或找到一个不是的，就退出</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//否则放到集合中</span></span><br><span class="line">				resIndexlist.add(temp);</span><br><span class="line">				temp+=<span class="number">1</span>;<span class="comment">//temp右移继续寻找</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> resIndexlist;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>插值查找类似于二分查找，其中它们不同的是mid的求法。</p>
<p>看一个案例：arr[1-100] 这是一个有1-100元素的数组，如果我用二分查找，查1时，这时候查找顺序为【50,25,12,6,3,1】 因为每次都取的是中间位置的数进行比较mid = (left+right)/2=left+(right-left)* 1/2</p>
<p>而插值查找<strong>mid = left + (right-left) * (findValue-arr[left]) / (arr[right]-arr[left])</strong></p>
<p>它是自适应的查找，此时我们可以看看找1的过程，首先mid=0+(99-0)*(1-1)/(100-1)=0+0=0,arr[0]=1完成</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 传入的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> findValue 查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 找到返回对应下标，没有找到返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertValueSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> findValue)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left &gt; right || findValue &lt; arr[<span class="number">0</span>] || findValue &gt;arr[arr.length-<span class="number">1</span>]) &#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//求出mid</span></span><br><span class="line">	<span class="keyword">int</span> mid = left + (right - left) * (findValue-arr[left]) / (arr[right]-arr[left]);</span><br><span class="line">	<span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line">	<span class="comment">//如果查找的值大于定位的值，说明向右递归（序列从小到大）</span></span><br><span class="line">	<span class="keyword">if</span>(findValue &gt; arr[mid]) &#123;</span><br><span class="line">		<span class="keyword">return</span> insertValueSearch(arr, mid+<span class="number">1</span>, right, findValue);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(findValue &lt; arr[mid]) &#123;</span><br><span class="line">		<span class="keyword">return</span> insertValueSearch(arr, left, mid-<span class="number">1</span>, findValue);</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> mid;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ol>
<li>对于数据量较大，关键字分步比较均匀的查找表来说，采用插值查找，速度较快</li>
<li>关键词分布不均匀的情况下，该方法不一定比折半查找要好</li>
</ol>
<h2 id="斐波那契查询"><a href="#斐波那契查询" class="headerlink" title="斐波那契查询"></a>斐波那契查询</h2><p>没整明白，下把代码放这里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> search;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilonacciSearch</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr= &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">89</span>,<span class="number">1000</span>,<span class="number">1234</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> index = filSearch(arr, <span class="number">89</span> );</span><br><span class="line">		System.out.println(index);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line">		<span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">		f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		f[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;maxSize;i++) &#123;</span><br><span class="line">			f[i] = f[i-<span class="number">1</span>] + f[i-<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> f;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写斐波那契查找算法</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> key 找的数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回对应下标，没有返回-1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">filSearch</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> hight = arr.length-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">//表示斐波那契分割数值的下标</span></span><br><span class="line">		<span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> f[] = fib();<span class="comment">//获取斐波那契数列</span></span><br><span class="line">		<span class="comment">//获取到斐波那契分割数值的下标</span></span><br><span class="line">		<span class="keyword">while</span>(hight &gt; f[k]-<span class="number">1</span>) &#123;</span><br><span class="line">			k++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//因为f[k]可能大于数组的长度，因此需要使用Arrays类，构造一个新的数组，并指向arr</span></span><br><span class="line">		<span class="keyword">int</span>[] temp = Arrays.copyOf(arr, f[k]);<span class="comment">//不足的部分使用零填充</span></span><br><span class="line">		<span class="comment">//实际上需求使用a数组最后的数填充temp</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = hight +<span class="number">1</span>;i&lt;temp.length;i++) &#123;</span><br><span class="line">			temp[i] = arr[hight];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(low &lt;= hight) &#123;</span><br><span class="line">			mid = low + f[k-<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(key&lt;temp[mid]) &#123;<span class="comment">//说明向数组的前面查找</span></span><br><span class="line">				hight = mid -<span class="number">1</span>;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 1.全部元素 = 前面+后面元素</span></span><br><span class="line"><span class="comment">				 * 2.f[k] = f[k-1]+f[k-2]</span></span><br><span class="line"><span class="comment">				 * 因为前面有f[k-1]个元素，所以可以继续拆分 f[k-1] = f[k-2]+f[k-3]</span></span><br><span class="line"><span class="comment">				 * 即在f[k-1]前面继续查找</span></span><br><span class="line"><span class="comment">				 * 即下次mid = f[k-1-1]-1</span></span><br><span class="line"><span class="comment">				 * */</span></span><br><span class="line">				k--;</span><br><span class="line">				</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(key&gt;temp[mid]) &#123;<span class="comment">//向后面查找</span></span><br><span class="line">				low = mid+<span class="number">1</span>;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 为什么是k-2</span></span><br><span class="line"><span class="comment">				 * 1.全部元素 = 前面+后面</span></span><br><span class="line"><span class="comment">				 * f[k] = f[k-1]+f[k-2]</span></span><br><span class="line"><span class="comment">				 * 因为后面f[k-2] 继续拆分 f[k-2] = f[k-3]+f[k-4]</span></span><br><span class="line"><span class="comment">				 **/</span></span><br><span class="line">				k-=<span class="number">2</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;<span class="comment">//找到</span></span><br><span class="line">				<span class="keyword">if</span>(mid &lt;=hight) &#123;</span><br><span class="line">					<span class="keyword">return</span> mid;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> hight;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//没找到</span></span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="哈希表（散列）-Google上机题"><a href="#哈希表（散列）-Google上机题" class="headerlink" title="哈希表（散列）-Google上机题"></a>哈希表（散列）-Google上机题</h2><p>有一个公司，当有新员工来报道时，要求将该员工的信息加入（id,性别,姓名….）当输入该员工的id时，要求查找到该员工的所有信息。<br>要求：不使用数据库，尽量节省内存，速度越快越好 =&gt;哈希表（散列）</p>
<h2 id="哈希表基本介绍"><a href="#哈希表基本介绍" class="headerlink" title="哈希表基本介绍"></a>哈希表基本介绍</h2><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过吧关键码值映射到表中一个位置来访问记录，以加快查找速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%93%88%E5%B8%8C%E8%A1%A81.png" alt=""></p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%93%88%E5%B8%8C%E8%A1%A82.png" alt=""></p>
<h2 id="实现哈希表-数组-链表"><a href="#实现哈希表-数组-链表" class="headerlink" title="实现哈希表 数组+链表"></a>实现哈希表 数组+链表</h2><p>这里我们使用数组+链表实现哈希表。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p><strong>创建雇员节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示一个雇员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> Emp next;<span class="comment">//默认为null</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建链表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建EmpLinkedList表示链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmpLinkedList</span></span>&#123;</span><br><span class="line">	<span class="comment">//头指针，执行第一个Emp，因此我们这个链表的head是直接指向第一个Emp</span></span><br><span class="line">	<span class="keyword">private</span> Emp head;</span><br><span class="line">	<span class="comment">//这下面还有增加到末尾，考虑顺序增加，查找，遍历，删除等方法，下面我们来一个一个加进去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现链表的增删改查方法"><a href="#实现链表的增删改查方法" class="headerlink" title="实现链表的增删改查方法"></a>实现链表的增删改查方法</h3><p>其实这里在前面单链表已经讲过。</p>
<h4 id="增加不考虑顺序"><a href="#增加不考虑顺序" class="headerlink" title="增加不考虑顺序"></a>增加不考虑顺序</h4><p>思路：不考虑顺序直接加到链表最后，遍历链表，找到最后，然后添加进去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//如果添加第一个雇员</span></span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			head = emp;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果不是第一个，则使用辅助指针直到最后</span></span><br><span class="line">		Emp curEmp = head;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(curEmp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			curEmp = curEmp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		curEmp.next = emp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这时候做这种操作已经非常easy了。</p>
<h4 id="增加考虑顺序"><a href="#增加考虑顺序" class="headerlink" title="增加考虑顺序"></a>增加考虑顺序</h4><p><strong>思路</strong>：找到要插入节点的前一个位置，然后进行插入</p>
<p><strong>步骤</strong>：</p>
<ol>
<li>首先要注意一点，以前单链表的操作，我们是有头结点的，头结点不存储数据，而这里我们的头结点存数据，就是第一个emp。</li>
<li>上来先判断，链表是不是空 <code>head==null</code>?，如果为空那就加到head就完了 <code>head=emp</code></li>
<li>如果head有值，即链表不为空，如果按我们以前的操作其实也很简单，我们来创建一个节点，充当不放数据的头结点的作用，而原来的头结点变为第一个数据节点。<code>Emp cur = new Emp();cur.next = head;</code></li>
<li>以上操作完成后，接下来的操作就跟上方单链表的一样了，如果看不懂，可以去前面看单链表的添加节点，那里比较详细，这里就不赘述了。</li>
</ol>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按id从小到大添加</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrderById</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			head = emp;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//判断所加id是否</span></span><br><span class="line">		<span class="comment">//不是第一个</span></span><br><span class="line">		Emp cur = <span class="keyword">new</span> Emp();</span><br><span class="line">		cur.next = head;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(cur.next == <span class="keyword">null</span>) &#123;<span class="comment">//到最后啦</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(cur.next.id  &gt; emp.id) &#123;<span class="comment">//当前节点下一个位置的id大于所加入的id，说明找到，就加到cur后面</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.next.id == emp.id) &#123;<span class="comment">//说明已经存在</span></span><br><span class="line">				System.out.println(<span class="string">"插入id已经存在！！！"</span>);</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur.next;<span class="comment">//后移</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"插入id=%d，已经存在！\n"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//插入操作</span></span><br><span class="line">			emp.next = cur.next;</span><br><span class="line">			cur.next = emp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h4><p>注意：这里的遍历方法多了个int参数，其实可以不要，主要是为了让后面哈希表调用的时候，打印出来的内容清楚一点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"第"</span>+(no+<span class="number">1</span>)+<span class="string">"条链表为空！"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(<span class="string">"第"</span>+(no+<span class="number">1</span>)+<span class="string">"条链表的信息为："</span>);</span><br><span class="line">		Emp cur = head;<span class="comment">//这里头结点就表示第一个员工了</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.printf(<span class="string">" =&gt; id=%d name=%s\t"</span> ,cur.id,cur.name);</span><br><span class="line">			<span class="keyword">if</span>(cur.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id查找雇员</span></span><br><span class="line">	<span class="comment">/*如果找到返回emp没找到返回空</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Emp <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//辅助指针</span></span><br><span class="line">		Emp cur = head;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(cur.id == id) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//这时cur就指向要查找的雇员</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//退出</span></span><br><span class="line">			<span class="keyword">if</span>(cur.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">//说明遍历没有找到</span></span><br><span class="line">				cur = <span class="keyword">null</span>;	</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur.next;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cur;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空！"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Emp cur = head;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(cur.next.id == id) &#123;<span class="comment">//找到要删除的节点的前一个位置</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(cur.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">"所删除员工不存在"</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//删除</span></span><br><span class="line">		cur.next = cur.next.next;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码都很简单，所以没有过多说明，不懂，可以去看上方单链表部分。</p>
<h3 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表，管理多条链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTab</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HashTab</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line">		<span class="keyword">this</span>.size = size;<span class="comment">//表示有过少条链表</span></span><br><span class="line">		empLinkedListArray = <span class="keyword">new</span> EmpLinkedList[size];</span><br><span class="line">		<span class="comment">//留一个坑，这时不要忘了分别初始化每一条链表</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++) &#123;</span><br><span class="line">			empLinkedListArray[i] = <span class="keyword">new</span> EmpLinkedList();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样其他的方法在下面一一列举。</p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>散列函数是哈希表的核心，实现散列的方法很多，这里我们用个简单的取模法来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个散列函数，使用一个简单的取模法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id % size;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增加操作"><a href="#增加操作" class="headerlink" title="增加操作"></a>增加操作</h4><p>这里的内容就比较简单了，总结为两点。</p>
<ol>
<li>通过id调用散列函数，得到散列值。散列值就代表哪一条链表。</li>
<li>链表调用对应方法即可</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//首先根据员工的id得到该员工应该添加到那条链表</span></span><br><span class="line">		<span class="keyword">int</span> empLinkedListNO = hashFun(emp.id);</span><br><span class="line">		empLinkedListArray[empLinkedListNO].add(emp);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrderById</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> empLinkedListNO = hashFun(emp.id);</span><br><span class="line">		empLinkedListArray[empLinkedListNO].addOrderById(emp);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历操作-1"><a href="#遍历操作-1" class="headerlink" title="遍历操作"></a>遍历操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有的链表，遍历哈希表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size;i++) &#123;</span><br><span class="line">			empLinkedListArray[i].list(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询操作-1"><a href="#查询操作-1" class="headerlink" title="查询操作"></a>查询操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id查找</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> empLinkedListNO = hashFun(id);</span><br><span class="line">		Emp emp = empLinkedListArray[empLinkedListNO].findEmpById(id);</span><br><span class="line">		<span class="keyword">if</span>(emp!=<span class="keyword">null</span>)&#123;<span class="comment">//说明找到</span></span><br><span class="line">			System.out.printf(<span class="string">"在第%d条链表中找到 雇员id=%d\n"</span>,(empLinkedListNO+<span class="number">1</span>),id);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"在哈希表中，没有找到该雇员"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除操作-2"><a href="#删除操作-2" class="headerlink" title="删除操作"></a>删除操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> empLinkedListNO = hashFun(id);</span><br><span class="line">		empLinkedListArray[empLinkedListNO].delEmpById(id);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码整合-测试"><a href="#代码整合-测试" class="headerlink" title="代码整合+测试"></a>代码整合+测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hashtab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTabDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//创键哈希表</span></span><br><span class="line">		HashTab hashTab = <span class="keyword">new</span> HashTab(<span class="number">7</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//写一个简单的菜单</span></span><br><span class="line">		String key = <span class="string">""</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"add:添加雇员"</span>);</span><br><span class="line">			System.out.println(<span class="string">"add2:顺序添加雇员"</span>);</span><br><span class="line">			System.out.println(<span class="string">"list:显示雇员"</span>);</span><br><span class="line">			System.out.println(<span class="string">"find:查找雇员"</span>);</span><br><span class="line">			System.out.println(<span class="string">"del:删除雇员"</span>);</span><br><span class="line">			System.out.println(<span class="string">"exit:退出系统"</span>);</span><br><span class="line">			</span><br><span class="line">			key = sc.next();</span><br><span class="line">			<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">				System.out.println(<span class="string">"输入id"</span>);</span><br><span class="line">				<span class="keyword">int</span> id = sc.nextInt();</span><br><span class="line">				System.out.println(<span class="string">"输入名字"</span>);</span><br><span class="line">				String name = sc.next();</span><br><span class="line">				Emp emp = <span class="keyword">new</span> Emp(id,name);</span><br><span class="line">				hashTab.add(emp);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"add2"</span>:</span><br><span class="line">				System.out.println(<span class="string">"输入id"</span>);</span><br><span class="line">				id = sc.nextInt();</span><br><span class="line">				System.out.println(<span class="string">"输入名字"</span>);</span><br><span class="line">			    name = sc.next();</span><br><span class="line">				emp = <span class="keyword">new</span> Emp(id,name);</span><br><span class="line">				hashTab.addOrderById(emp);</span><br><span class="line">				<span class="keyword">break</span>;	</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"list"</span>:</span><br><span class="line">				hashTab.list();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"del"</span>:</span><br><span class="line">				System.out.println(<span class="string">"输入id"</span>);</span><br><span class="line">				id = sc.nextInt();</span><br><span class="line">				hashTab.delEmpById(id);</span><br><span class="line">				<span class="keyword">break</span>;	</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"find"</span>:</span><br><span class="line">				System.out.println(<span class="string">"请输入要查找的id"</span>);</span><br><span class="line">				id = sc.nextInt();</span><br><span class="line">				hashTab.findEmpById(id);</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">break</span>;	</span><br><span class="line">			<span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">				sc.close();</span><br><span class="line">				System.exit(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表，管理多条链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTab</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HashTab</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line">		<span class="keyword">this</span>.size = size;<span class="comment">//表示有过少条链表</span></span><br><span class="line">		empLinkedListArray = <span class="keyword">new</span> EmpLinkedList[size];</span><br><span class="line">		<span class="comment">//留一个坑，这时不要忘了分别初始化每一条链表</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;size;i++) &#123;</span><br><span class="line">			empLinkedListArray[i] = <span class="keyword">new</span> EmpLinkedList();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//首先根据员工的id得到该员工应该添加到那条链表</span></span><br><span class="line">		<span class="keyword">int</span> empLinkedListNO = hashFun(emp.id);</span><br><span class="line">		empLinkedListArray[empLinkedListNO].add(emp);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//遍历所有的链表，遍历哈希表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;size;i++) &#123;</span><br><span class="line">			empLinkedListArray[i].list(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据id查找</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> empLinkedListNO = hashFun(id);</span><br><span class="line">		Emp emp = empLinkedListArray[empLinkedListNO].findEmpById(id);</span><br><span class="line">		<span class="keyword">if</span>(emp!=<span class="keyword">null</span>)&#123;<span class="comment">//说明找到</span></span><br><span class="line">			System.out.printf(<span class="string">"在第%d条链表中找到 雇员id=%d\n"</span>,(empLinkedListNO+<span class="number">1</span>),id);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"在哈希表中，没有找到该雇员"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> empLinkedListNO = hashFun(id);</span><br><span class="line">		empLinkedListArray[empLinkedListNO].delEmpById(id);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrderById</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> empLinkedListNO = hashFun(emp.id);</span><br><span class="line">		empLinkedListArray[empLinkedListNO].addOrderById(emp);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写一个散列函数，使用一个简单的取模法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id % size;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//表示一个雇员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> Emp next;<span class="comment">//默认为null</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建EmpLinkedList表示链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmpLinkedList</span></span>&#123;</span><br><span class="line">	<span class="comment">//头指针，执行第一个Emp，因此我们这个链表的head是直接指向第一个Emp</span></span><br><span class="line">	<span class="keyword">private</span> Emp head;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加雇员到链表</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 添加雇员时，id自增，从小到大</span></span><br><span class="line"><span class="comment">	 * 直接加到最后</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//如果添加第一个雇员</span></span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			head = emp;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果不是第一个，则使用辅助指针直到最后</span></span><br><span class="line">		Emp curEmp = head;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(curEmp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			curEmp = curEmp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		curEmp.next = emp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//按id从小到大添加</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrderById</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			head = emp;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//判断所加id是否</span></span><br><span class="line">		<span class="comment">//不是第一个</span></span><br><span class="line">		Emp cur = <span class="keyword">new</span> Emp();</span><br><span class="line">		cur.next = head;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(cur.next == <span class="keyword">null</span>) &#123;<span class="comment">//到最后啦</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(cur.next.id  &gt; emp.id) &#123;<span class="comment">//当前节点下一个位置的id大于所加入的id，说明找到，就加到cur后面</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.next.id == emp.id) &#123;<span class="comment">//说明已经存在</span></span><br><span class="line">				System.out.println(<span class="string">"插入id已经存在！！！"</span>);</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur.next;<span class="comment">//后移</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"插入id=%d，已经存在！\n"</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//插入操作</span></span><br><span class="line">			emp.next = cur.next;</span><br><span class="line">			cur.next = emp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//遍历链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"第"</span>+(no+<span class="number">1</span>)+<span class="string">"条链表为空！"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.print(<span class="string">"第"</span>+(no+<span class="number">1</span>)+<span class="string">"条链表的信息为："</span>);</span><br><span class="line">		Emp cur = head;<span class="comment">//这里头结点就表示第一个员工了</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.printf(<span class="string">" =&gt; id=%d name=%s\t"</span> ,cur.id,cur.name);</span><br><span class="line">			<span class="keyword">if</span>(cur.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//根据id查找雇员</span></span><br><span class="line">	<span class="comment">/*如果找到返回emp没找到返回空</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Emp <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//辅助指针</span></span><br><span class="line">		Emp cur = head;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(cur.id == id) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//这时cur就指向要查找的雇员</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//退出</span></span><br><span class="line">			<span class="keyword">if</span>(cur.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">//说明遍历没有找到</span></span><br><span class="line">				cur = <span class="keyword">null</span>;	</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur.next;			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cur;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表为空！"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Emp cur = head;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(cur.next.id == id) &#123;<span class="comment">//找到要删除的节点的前一个位置</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(cur.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">"所删除员工不存在"</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cur = cur.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//删除</span></span><br><span class="line">		cur.next = cur.next.next;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树结构的基础部分"><a href="#树结构的基础部分" class="headerlink" title="树结构的基础部分"></a>树结构的基础部分</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="为什么需要树这种数据结构"><a href="#为什么需要树这种数据结构" class="headerlink" title="为什么需要树这种数据结构"></a>为什么需要树这种数据结构</h3><p><strong>1.数组存储方式的分析</strong></p>
<p>优点：通过<strong>下标方式访问元素</strong>，速度快。对于有序数组，还可以使用二分查找提高检索速度。</p>
<p>缺点：如果药检所具体的某个值，后者插入值（按一定顺序）会整体移动，效率低。</p>
<p><strong>2.链式存储方式的分析</strong></p>
<p>优点：在一定程度上对数组存储方式有优化（比如：插入一个数值节点，只需要将插入节点，连接到链表中即可），删除也是找到然后直接删除。</p>
<p>缺点：在进行检索时，效率任然较低，比如（检索某个值，需要从头节点开始遍历）。</p>
<p><strong>3.数存储方式的分析</strong></p>
<p>能提高数据存储、读取的效率，比如利用二叉排序树，既可以保证数组的检索速度，同时也可以保证数据的插入，删除，修改的速度。</p>
<h3 id="树的示意图"><a href="#树的示意图" class="headerlink" title="树的示意图"></a>树的示意图</h3><p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%A0%91%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p>
<p>常用术语（结合图理解）：</p>
<ol>
<li>节点：就是每一个圈</li>
<li>根节点：第一个节点，如图圈A</li>
<li>父节点：例如A是B,C的父节点</li>
<li>子节点</li>
<li>叶子节点：下面没有节点了，就是叶子节点</li>
<li>节点的权：就是值</li>
<li>路径：从root节点找到该节点的路线</li>
<li>层</li>
<li>子树</li>
<li>树的高度（最大层数）</li>
<li>森林：多个子树构成森林</li>
</ol>
<h3 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h3><ol>
<li><p>树有很多种，每个节点<strong>最多只能有两个子节点</strong>的一种形式称为二叉树。</p>
</li>
<li><p>二叉树的子节点分为左节点和右节点</p>
</li>
<li><p>示意图<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p>
</li>
<li><p>如果该二叉树的所有叶子节点都在<strong>最后一层</strong>，并且<strong>节点总数=2^n-1</strong>，n为层数，则我们称为man二叉树。<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""></p>
</li>
<li><p>如果该二叉树的所有<strong>叶子节点</strong>都在<strong>最后一层</strong>或者<strong>倒数第二层</strong>，而且最糊一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""></p>
</li>
</ol>
<h3 id="二叉树遍历的说明"><a href="#二叉树遍历的说明" class="headerlink" title="二叉树遍历的说明"></a>二叉树遍历的说明</h3><p>使用前序，中序和后序遍历对下面的二叉树进行遍历。</p>
<ol>
<li>前序遍历：先输出父节点，再遍历左子树和右子树。</li>
<li>中序遍历：先遍历左子树，再输出父节点，再遍历遍历右子树。</li>
<li>后序遍历：先遍历左子树，在输出父节点，在遍历右子树。</li>
<li>小结：从父节点的顺序就确定是哪种遍历。□左□右□  就看父节点在哪了。</li>
</ol>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p>思路：</p>
<ol>
<li>前序遍历：<ul>
<li>先输出当前节点。</li>
<li>如果左节点不为空，就递归前序遍历。</li>
<li>如果右节点不为空，就递归前序遍历。</li>
</ul>
</li>
<li>中序遍历：<ul>
<li>如果左节点不为空，就递归中序遍历。</li>
<li>输出当前节点。</li>
<li>如果右节点不为空，就递归中序遍历。</li>
</ul>
</li>
<li>后序遍历<ul>
<li>如果左节点不为空，就递归后序遍历。</li>
<li>如果右节点不为空，就递归后序遍历。</li>
<li>输出当前节点。</li>
</ul>
</li>
</ol>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><p><strong>先创建节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先创建节点HeroNode</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> HeroNode left;</span><br><span class="line">	<span class="keyword">private</span> HeroNode right;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no,String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.left = left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.right = right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们设计把对应方法放到节点类里，然后树类调用节点类的方法。</p>
<p><strong>前序遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写前序遍历</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>);<span class="comment">//先输出父节点</span></span><br><span class="line">		<span class="comment">//递归向左子树</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//递归向右子树</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.preOrder();</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中序遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写中序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//先递归向左子树</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//输出父节点</span></span><br><span class="line">		System.out.println(<span class="keyword">this</span>);</span><br><span class="line">		<span class="comment">//再向右递归</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后序遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.postOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.postOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义二叉树</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义BinaryTree二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.root = root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.root.preOrder();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"二叉树为空无法遍历"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"二叉树为空无法遍历"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.root.postOrder();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"二叉树为空无法遍历"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><em>注意：按理说节点的作用只是存放数据，对应的遍历或其他操作方法应该直接在二叉树类里面。这里也可以直接把遍历方法写到二叉树类里，只不过，调用的时候把对应节点当参数传进去就好了。</em></p>
<h3 id="二叉树查找指定节点"><a href="#二叉树查找指定节点" class="headerlink" title="二叉树查找指定节点"></a>二叉树查找指定节点</h3><p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9%E5%9B%BE.png" alt=""></p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><p>比较简单，就是遍历的基础上加上判断，代码一块放出来了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历查找</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//比较当前节点</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.no==no) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//向左</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(resNode!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> resNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//向右</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//最后直接返回结果，找到就找到了，没找到就是空</span></span><br><span class="line">		<span class="keyword">return</span> resNode;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(resNode!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> resNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resNode;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//后续遍历查找</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(resNode!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> resNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			resNode = <span class="keyword">this</span>.right.postOrderSearch(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(resNode!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> resNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.no==no) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树删除节点"><a href="#二叉树删除节点" class="headerlink" title="二叉树删除节点"></a>二叉树删除节点</h3><p>要求：</p>
<ol>
<li>删除的节点如果是叶子节点，则删除的就是该节点</li>
<li>删除的节点如果是非叶子节点，则删除该子树</li>
</ol>
<p><strong>代码实现</strong></p>
<p>Node节点中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归删除节点</span></span><br><span class="line">	<span class="comment">/* 1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line"><span class="comment">	 * 2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp;<span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//向左子树递归删除</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//向右子树递归删除</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>树里的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(root.getNo()==no) &#123;</span><br><span class="line">				root = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				root.delNode(no);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"空树不能删除"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>其实这里因为二叉树没有任何规则，所以这里删除会遍历一遍二叉树，删除所有满足条件的。</p>
<h2 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>从数据存储来看，数组存储方式和树存储方式可以互相转换，即数组可以转换成树，树也可以转换成数组。<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""></p>
<p><strong>要求</strong></p>
<ol>
<li>上图的二叉树的节点，要求以数组的方式来存放 arr:[1,2,3,4,5,6]</li>
<li>要求在遍历数组arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成节点的遍历。</li>
</ol>
<h3 id="顺序存储二叉树的特点"><a href="#顺序存储二叉树的特点" class="headerlink" title="顺序存储二叉树的特点"></a>顺序存储二叉树的特点</h3><ol>
<li>顺序二叉树通常只考虑完全全二叉树</li>
<li>第n个元素的左子节点为2*n+1</li>
<li>第n个元素的右子节点为2*n+2</li>
<li>第n个元素的父节点为（n-1）/2</li>
<li>n:表示二叉树中的第几个元素（按0开始编号）</li>
</ol>
<h3 id="实现前序遍历"><a href="#实现前序遍历" class="headerlink" title="实现前序遍历"></a>实现前序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr= &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">		ArrayBinaryTree tree = <span class="keyword">new</span> ArrayBinaryTree(arr);</span><br><span class="line">		tree.preOrder();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编写树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayBinaryTree</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存储数据的数组，即二叉树节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayBinaryTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayBinaryTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.arr = arr;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//重载</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写方法，完成顺序存储二叉树的前序遍历</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index 数组下标</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//如果数组为空，或者arr.length=0</span></span><br><span class="line">		<span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length==<span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"数组为空，不能按照二叉树的前序遍历"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//输出当前元素</span></span><br><span class="line">		System.out.println(arr[index]);</span><br><span class="line">		<span class="comment">//向左递归遍历</span></span><br><span class="line">		<span class="keyword">if</span>((<span class="number">2</span>*index+<span class="number">1</span>) &lt; arr.length) &#123;<span class="comment">//判断是否越界</span></span><br><span class="line">			preOrder(<span class="number">2</span>*index+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//向右递归</span></span><br><span class="line">		<span class="keyword">if</span>((<span class="number">2</span>*index+<span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">			preOrder(<span class="number">2</span>*index+<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h2><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><p>将数列{1,3,6,8,10,14}构建成一颗二叉树 n+1=7.</p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%9101.png" alt=""></p>
<p>问题分析：</p>
<ol>
<li>当我们对上面的二叉树进行中序遍历时，数列为{8,3,10,1,6,14}</li>
<li>但是6,8,10,14这几个节点的左右指针并没有完全的利用上</li>
<li>如果我们希望充分利用各个节点的左右指针，让各个节点可以指向自己的前后节点怎么办？</li>
<li>解决方案：线索二叉树。</li>
</ol>
<h3 id="线索二叉树基本介绍"><a href="#线索二叉树基本介绍" class="headerlink" title="线索二叉树基本介绍"></a>线索二叉树基本介绍</h3><ol>
<li>n个节点的二叉链表中含有n+1【公式 2n-(n-11) = n+1】个空指针域。利用二叉链表中的空指针域，存放指向该节点在某种遍历次序下的前驱和后继节点的指针（这种附加的指针称为“线索”）。<ul>
<li>解释一下公式：因为n个点可以用n-1条线连起来，每条线就相当于一个指针，这样就用了n-1个指针。而一个点有两个指针，总共2n个，所以，没使用的就是2n-(n-1)=n+1</li>
</ul>
</li>
<li>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded Binary Tree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树，中序线索二叉树和后序线索二叉树。</li>
<li>一个节点的前一个节点，称为<strong>前驱</strong>节点</li>
<li>一个节点的后一个节点，称为<strong>后继</strong>节点</li>
</ol>
<h3 id="线索二叉树应用案例"><a href="#线索二叉树应用案例" class="headerlink" title="线索二叉树应用案例"></a>线索二叉树应用案例</h3><p>将上方提出问题中的数，进行中序线索二叉树。中序遍历的数列为{8,3,10,1,14,6}</p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""></p>
<p><strong>说明</strong>：当线索化二叉树后，Node节点的属性left和right，有如下情况：</p>
<ol>
<li><strong>left</strong>指向的是<strong>左子树</strong>，也可能是指向的<strong>前驱节点</strong>，比如①节点left指向的左子树，而⑩节点的left指向的就是前驱节点。</li>
<li><strong>right</strong>指向的是<strong>右子树</strong>，也可能指向<strong>后继节点</strong>，比如①节点right指向的是右子树，而⑩节点的right指向的就是后继节点。</li>
</ol>
<h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><p>首先先创建一个节点，这个节点与前面的不同，多了两个标志位。</p>
<ol>
<li><code>private int leftType;</code>值=1表示指向的是前驱节点，0表示指向左子树</li>
<li><code>private int rightType;</code>值=1表示指向的是后继节点，0表示指向右子树</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先创建节点HeroNode</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> HeroNode left;</span><br><span class="line">	<span class="keyword">private</span> HeroNode right;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 规定：leftType=0表示指向左子树，如果=1，表示指向前驱节点</span></span><br><span class="line"><span class="comment">	 * rightType = 0表示指向右子树 rightType=1表示指向后继节点</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> leftType;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rightType;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no,String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> leftType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rightType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.left = left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.right = right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定义线索化二叉树</strong></p>
<p>这里比之前多了一个指针pre，在线索化时指向前一个节点。其中我们还会在里面加入线索化方法和遍历方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义线索化二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> HeroNode root;</span><br><span class="line">	<span class="comment">//为了实现线索化，需要创建要指向当前节点的前驱结点的指针</span></span><br><span class="line">	<span class="comment">//在递归进行线索化时pre总是保留前一个节点</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode pre=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.root = root;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中序线索化</strong></p>
<p>思路：</p>
<ol>
<li>首先要把线索化的节点传入，一般是传入根节点，</li>
<li>首先判断node是不是空，如果是空，就直接返回，因为没有东西。</li>
<li>中序线索化，顺序为 左 中 右。<ol>
<li>先处理左子树，所以递归调用threadedNodes(node.left)传入左子节点。这里就跟中序遍历类似，会一直递归，找到最左边的节点。找到该节点，然后再去threadedNodes(node.left)，这时node==null，就返回了。</li>
<li>返回之后就要进行下一步，处理当前节点。<ol>
<li>首先就要判断当前node的左子树是不是null,如果不是说明，它不是叶子节点，它的left指向左子树。</li>
<li>如果是null，就让它指向pre,因为我们说了pre在线索化时，指向上一个节点，相当于该节点的前驱结点。此时pre为默认值null。因为中序遍历的左边第一个节点，它没有前驱节点，它就是第一个。然后别忘了把标志位leftType=1.</li>
<li>第三步要处理后继节点。这里要注意一下，pre保存了前一个节点，所以我们可以在当前node中处理前驱节点。但是，我们并没有创建一个指针，指向当前节点的后一个节点，因此我们无法在当前节点来处理它的后继节点。但是由于下一个节点就是当前node的后继节点，而pre保存上一个节点，所以，当node走到下一个节点时，此时的node就是pre的后继节点。</li>
<li>总结：当前节点的后继节点，要在当前节点的下一个节点处，通过pre处理。</li>
<li>处理时：判断pre是否为null,因为第一个节点时pre为默认值null。然后判断pre.right是否为null,因为为空才可以处理！都成立，则pre的右指针指向node，标示位rightType=1.</li>
<li>当处理完一个节点后，pre要移动pre=node，这样pre才能总是指向node的前一个节点。</li>
</ol>
</li>
<li>然后按照中序规则，传入右指针，递归遍历<code>threadedNodes(node.right)</code></li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写对二叉树进行中序线索化</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//如果node=null</span></span><br><span class="line">		<span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//中序线索化</span></span><br><span class="line">		<span class="comment">//&lt;一&gt;先线索化左子树</span></span><br><span class="line">		threadedNodes(node.getLeft());</span><br><span class="line">		<span class="comment">//&lt;二&gt;线索化当前节点</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//处理当前节点的前驱节点</span></span><br><span class="line">		<span class="keyword">if</span>(node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//让当前节点的左指针指向前驱节点</span></span><br><span class="line">			node.setLeft(pre);</span><br><span class="line">			<span class="comment">//修改当前节点的左指针类型</span></span><br><span class="line">			node.setLeftType(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//处理后继节点</span></span><br><span class="line">		<span class="keyword">if</span>(pre!=<span class="keyword">null</span> &amp;&amp; pre.getRight()==<span class="keyword">null</span>) &#123;</span><br><span class="line">			pre.setRight(node);</span><br><span class="line">			pre.setRightType(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//!!!每处理一个节点后，让当前节点是下一个节点的前驱节点</span></span><br><span class="line">		pre = node;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//&lt;三&gt;线索化右子树</span></span><br><span class="line">		threadedNodes(node.getRight());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这里会比较绕，建议自己画图一步一步的理顺一下，体会执行过程。</p>
<p><strong>遍历中序线索化二叉树</strong></p>
<p>因为线索化之后前面的遍历方法不能用了，所以要重新写一个。</p>
<p>这里顺着代码走一遍还是很好理解的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历中序线索化二叉树</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//临时存储当前遍历的节点</span></span><br><span class="line">		HeroNode node = root;</span><br><span class="line">		<span class="keyword">while</span>(node!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//循环找到leftType == 1的节点</span></span><br><span class="line">			<span class="comment">//后面随着遍历，node会变化，因为当left=1时，说明该节点是按照线索化处理后的有效节点</span></span><br><span class="line">			<span class="keyword">while</span>(node.getLeftType()==<span class="number">0</span>) &#123;</span><br><span class="line">				node = node.getLeft();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//打印当前节点</span></span><br><span class="line">			System.out.println(node);</span><br><span class="line">			<span class="comment">//如果当前节点的右指针，指向的的后继节点，就一直输出</span></span><br><span class="line">			<span class="keyword">while</span>(node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">//获取到当前节点的后继节点</span></span><br><span class="line">				node =node.getRight();</span><br><span class="line">				System.out.println(node);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//替换遍历的节点</span></span><br><span class="line">			node = node.getRight();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码整合</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> tree.threadedBinaryTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//测试</span></span><br><span class="line">		HeroNode h1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"tom"</span>);</span><br><span class="line">		HeroNode h2 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"jack"</span>);</span><br><span class="line">		HeroNode h3 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>, <span class="string">"smith"</span>);</span><br><span class="line">		HeroNode h4 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">"mery"</span>);</span><br><span class="line">		HeroNode h5 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>, <span class="string">"king"</span>);</span><br><span class="line">		HeroNode h6 = <span class="keyword">new</span> HeroNode(<span class="number">14</span>, <span class="string">"dim"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//二叉树，后面递归创建，先暂时手动创建</span></span><br><span class="line">		h1.setLeft(h2);</span><br><span class="line">		h1.setRight(h3);</span><br><span class="line">		h2.setLeft(h4);</span><br><span class="line">		h2.setRight(h5);</span><br><span class="line">		h3.setLeft(h6);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//测试线索化</span></span><br><span class="line">		ThreadedBinaryTree tree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">		tree.setRoot(h1);</span><br><span class="line">		tree.threadedNodes();</span><br><span class="line">		</span><br><span class="line">		HeroNode leftNode = h5.getLeft();</span><br><span class="line">		System.out.println(<span class="string">"10号节点的前驱节点是："</span>+leftNode);</span><br><span class="line">		HeroNode rightNode = h5.getRight();</span><br><span class="line">		System.out.println(<span class="string">"10号节点的后继节点是："</span>+rightNode);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"使用线索化的方式遍历线索化二叉树"</span>);</span><br><span class="line">		tree.threadedList();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义线索化二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> HeroNode root;</span><br><span class="line">	<span class="comment">//为了实现线索化，需要创建要指向当前节点的前驱结点的指针</span></span><br><span class="line">	<span class="comment">//在递归进行线索化时pre总是保留前一个节点</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode pre=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.root = root;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//遍历中序线索化二叉树</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//临时存储当前遍历的节点</span></span><br><span class="line">		HeroNode node = root;</span><br><span class="line">		<span class="keyword">while</span>(node!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//循环找到leftType == 1的节点</span></span><br><span class="line">			<span class="comment">//后面随着遍历，node会变化，因为当left=1时，说明该节点是按照线索化处理后的有效节点</span></span><br><span class="line">			<span class="keyword">while</span>(node.getLeftType()==<span class="number">0</span>) &#123;</span><br><span class="line">				node = node.getLeft();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//打印当前节点</span></span><br><span class="line">			System.out.println(node);</span><br><span class="line">			<span class="comment">//如果当前节点的右指针，指向的的后继节点，就一直输出</span></span><br><span class="line">			<span class="keyword">while</span>(node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">//获取到当前节点的后继节点</span></span><br><span class="line">				node =node.getRight();</span><br><span class="line">				System.out.println(node);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//替换遍历的节点</span></span><br><span class="line">			node = node.getRight();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//重载</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.threadedNodes(root);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写对二叉树进行中序线索化</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> node 当前需要线索化的节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//如果node=null</span></span><br><span class="line">		<span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//中序线索化</span></span><br><span class="line">		<span class="comment">//&lt;一&gt;先线索化左子树</span></span><br><span class="line">		threadedNodes(node.getLeft());</span><br><span class="line">		<span class="comment">//&lt;二&gt;线索化当前节点</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//处理当前节点的前驱节点</span></span><br><span class="line">		<span class="keyword">if</span>(node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//让当前节点的左指针指向前驱节点</span></span><br><span class="line">			node.setLeft(pre);</span><br><span class="line">			<span class="comment">//修改当前节点的左指针类型</span></span><br><span class="line">			node.setLeftType(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//处理后继节点</span></span><br><span class="line">		<span class="keyword">if</span>(pre!=<span class="keyword">null</span> &amp;&amp; pre.getRight()==<span class="keyword">null</span>) &#123;</span><br><span class="line">			pre.setRight(node);</span><br><span class="line">			pre.setRightType(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//!!!每处理一个节点后，让当前节点是下一个节点的前驱节点</span></span><br><span class="line">		pre = node;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//&lt;三&gt;线索化右子树</span></span><br><span class="line">		threadedNodes(node.getRight());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建节点HeroNode</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> HeroNode left;</span><br><span class="line">	<span class="keyword">private</span> HeroNode right;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 规定：leftType=0表示指向左子树，如果=1，表示指向前驱节点</span></span><br><span class="line"><span class="comment">	 * rightType = 0表示指向右子树 rightType=1表示指向后继节点</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> leftType;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rightType;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no,String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> leftType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rightType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.left = left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.right = right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ol>
<li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏、最好、平均时间复杂度均为O(nlogn)，它也是不稳定排序。</p>
</li>
<li><p>堆是具有以下性质的完全二叉树：每个节点的值都大于或等于左右孩子节点的值，称之为大顶堆。注意：没有要求左右孩子值的大小关系。</p>
</li>
<li><p>每个节点的值都小于或等于左右孩子节点的值，称之为小顶堆。</p>
</li>
<li><p>大顶堆举例<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A4%A7%E9%A1%B6%E5%A0%86%E4%B8%BE%E4%BE%8B.png" alt=""></p>
</li>
<li><p>小顶堆举例<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%B0%8F%E9%A1%B6%E5%A0%86%E4%B8%BE%E4%BE%8B.png" alt=""></p>
</li>
<li><p>一般升序采用大顶堆，降序采用小顶堆。</p>
</li>
</ol>
<h3 id="堆排序基本思想"><a href="#堆排序基本思想" class="headerlink" title="堆排序基本思想"></a>堆排序基本思想</h3><ol>
<li>将待排序序列构成一个大顶堆</li>
<li>此时，整个序列的最大值就是堆顶的根节点。</li>
<li>将其与末尾元素进行交换，此时末尾就为最大值。</li>
<li>然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。</li>
</ol>
<h3 id="堆排序步骤图解说明"><a href="#堆排序步骤图解说明" class="headerlink" title="堆排序步骤图解说明"></a>堆排序步骤图解说明</h3><p>要求：给你一个数组{4,6,8,5,9}，要求使用堆排序法，将数组升序排序。</p>
<h4 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h4><p><strong>步骤一</strong>：构造初始堆。将无序序列构造成一个大顶堆。</p>
<ol>
<li><p>假设给定无序序列结构如下<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A401.png" style="zoom:50%;" /></p>
</li>
<li><p>此时我们从<strong>最后一个非叶子节点</strong>开始（叶子节点自然不用调整，第一个非叶子节点 arr.length/2-1=5/2-1=1，也就是下面的6节点），<strong>从左至右，从下至上</strong>进行调整。<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A402.png" style="zoom: 50%;" /></p>
</li>
<li><p>找到第二个非叶子节点4，由于[4,9,8]中9元素最大，4和9交换。<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A403.png" style="zoom:50%;" /></p>
</li>
<li><p>这时，交换导致了子跟[4,5,6]结构混乱，继续调整，[4,5,6]中6最大，交换4和6。<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A404.png" style="zoom:50%;" /></p>
</li>
</ol>
<p>此时，我们就将一个无序序列构建成了一个大顶堆。</p>
<h4 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h4><p><strong>将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将对顶元素与末尾元素交换，得到第二大元素，如此反复进行交换、重建、交换。</strong></p>
<ol>
<li><p>将堆顶元素9与末尾元素4进行交换<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A405.png" style="zoom:50%;" /></p>
</li>
<li><p>继续调整结构，使其满足堆定义。<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A406.png" style="zoom:50%;" /></p>
</li>
<li><p>再将堆顶元素8与末尾元素4进行交换，得到第二大元素8。<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A407.png" style="zoom:50%;" /></p>
</li>
<li><p>后续过程，继续进行调整、交换，如此反复进行，最终使得整个序列有序。<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%AD%A5%E9%AA%A408.png" style="zoom: 33%;" /></p>
</li>
</ol>
<h3 id="堆排序代码实现"><a href="#堆排序代码实现" class="headerlink" title="堆排序代码实现"></a>堆排序代码实现</h3><p><strong>首先编写一个方法，功能为将一个数组（二叉树），调整成一个大顶堆。</strong></p>
<p>思路：</p>
<ol>
<li>三个参数，数组，节点下标，以及数组长度</li>
<li>创建临时变量，保存当前下标对应的值。</li>
<li>由公式可知：当前下标为i的左子树的下标为<code>2*i+1</code>，右子树为<code>2*i+2</code></li>
<li>首先循环从左节点开始，<code>k=i*2+1</code>，结束条件是k&lt;length，因为我们是先找的左节点，然后比较，所以k每次都要找左节点，所以k每次<code>k=*2+1</code><ol>
<li>进入循环，因为要比较左右节点的值，所以下看一下有没有右节点，也就是k+1&lt;length吗</li>
<li>如果k+1&lt;length成立，也就是有右节点，然后进行比较，如果左节小于右节点，则k++，这样k就会指向右节点。如果左节点不小于右节点，那么k指向的还是左节点没有变化。</li>
<li>比较完以后，k就会指向左右节点中最大的那个，然后就比较这个节点与父节点谁大，如果当前节点大于父节点，那么将当前节点赋值给父节点。令i=k，这时候最大节点的位置。（用于后面放置原来的父节点。）</li>
<li>如果当前节点不大于父节点，也就是不需要交换，那我就可以直接退出循环break。可以直接break的原因是我们<strong>从左至右，从下到上</strong>进行处理。下面肯定是处理后的了。</li>
</ol>
</li>
<li>循环结束后将temp中存储的原父节点，放到i所指向的位置，实现交换。</li>
</ol>
<p>​    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个数组（二叉树）调整成一个大顶堆</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 功能：完成将以i对应的非叶子节点的数，调整成大顶堆</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr 待调整的数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i 表示非叶子节点的在数组中的索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> length 表示对多少个元素进行调整，length是在逐渐减少</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> temp = arr[i];<span class="comment">//临时变量</span></span><br><span class="line">		<span class="comment">//开始调整</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * k = i*2+1 是i节点的左子节点</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k = k*<span class="number">2</span>+<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k] &lt; arr[k+<span class="number">1</span>]) &#123;<span class="comment">//说明左子节点小于右子节点的值</span></span><br><span class="line">				k++;<span class="comment">//k指向右子节点</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(arr[k] &gt; temp) &#123;<span class="comment">//子节点大于父节点</span></span><br><span class="line">				arr[i]= arr[k];<span class="comment">//把较大的值，赋给当前节点</span></span><br><span class="line">				i=k;<span class="comment">//然后i指向k继续循环比较</span></span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//for循环结束后，我们已经将以i为父节点的树的最大值，放在了最顶（局部）</span></span><br><span class="line">		arr[i] = temp;<span class="comment">//将temp放到调整后的位置 </span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后编写排序</strong></p>
<p>思路：</p>
<ol>
<li>现将无序序列构建成一个堆，升序大顶堆，降序小顶堆</li>
<li>将堆顶元素与末尾元素进行交换，将最大元素沉到数组末端</li>
<li>重新调整结构使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</li>
<li>从代码中可以看出i=arr.length/2-1其实是最后一层最左边节点，也就是我们要<strong>从左至右，从下至上</strong>操作。</li>
<li>第一步将无序序列转换为堆后，交换堆顶元素和末尾元素，这时就要从根节点开始调整，每次都是从这里开始。因为长度不断减少，最后换过去的元素，就不会在下次调整的数组中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写堆排序</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"堆排序"</span>);</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//交换辅助变量</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">			adjustHeap(arr, i, arr.length);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*将堆顶元素与末尾元素交换，将最大元素沉到数组末端</span></span><br><span class="line"><span class="comment">		 * 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，知道整个序列有序</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j =arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--) &#123;</span><br><span class="line">			temp = arr[j];</span><br><span class="line">			arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">			arr[<span class="number">0</span>] = temp;</span><br><span class="line">			adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"数组="</span>+Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>我认为堆排序的思路就是，由于根节点必然大于其他节点（大顶堆），小顶堆反之。所以要一步一步选出根节点元素，与末尾元素交换，因此它是选择排序。就是因为根节点的值，在大顶堆必然最大，小顶堆必然最小。</p>
<h1 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h1><h2 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol>
<li>给定n个权值作为n个叶子节点，构造一颗二叉树，若该树的带权路径长度（wpl）达到最小，称这样的二叉树为最优二叉树，也称为赫夫曼树（Huffman Tree）。</li>
<li>赫夫曼树是带权路径长度最短的树，权值较大的节点离根较近。</li>
</ol>
<h2 id="几个重要的概念"><a href="#几个重要的概念" class="headerlink" title="几个重要的概念"></a>几个重要的概念</h2><ol>
<li><strong>路径和路径长度</strong>：在一棵树中，从一个节点往下可以达到的孩子或孙子节点之间的通路，称为路径。<strong>通路中分支的数目称为路径长度</strong>。若规定根节点的层数为1，则从根节点到L层节点的路径长度为L-1。</li>
<li><strong>节点的权及带权路径长度</strong>：若将树中系欸但赋给一个有着某种含义的数值，则这个数值称为该节点的权。<strong>节点的带权路径长度为：</strong>从根节点到该节点之间的路径长度与该节点的权的乘积。</li>
<li>树的带权路径长度：树的带权路径长度规定为<strong>所有叶子节点的带权路径长度之和</strong>，记为WPL，权值越大的节点离根节点越近的二叉树才是最优二叉树。</li>
<li>举例<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%BE%E4%BE%8B.png" alt=""></li>
</ol>
<h2 id="赫夫曼树创建"><a href="#赫夫曼树创建" class="headerlink" title="赫夫曼树创建"></a>赫夫曼树创建</h2><h4 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h4><ol>
<li>从小到大进行排序，将每一个数据，每个数据都是一个节点，每个节点可以看成一颗最简单的二叉树。</li>
<li>取出根节点权值最小的两颗二叉树</li>
<li>组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和。</li>
<li>再将这颗新的二叉树，以根节点的权值大小，再次排序，不断重复1-4步骤，直到数列中，所有的数据都被处理，就得到了一颗赫夫曼树。</li>
</ol>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>{13,7,8,3,29,6,1}为例</p>
<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%88%9B%E5%BB%BA%E5%9B%BE%E8%A7%A3.png" style="zoom: 67%;" />

<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> huffmantree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> arr[] = &#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">29</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line">		Node root = createHuffmanTree(arr);</span><br><span class="line">		preOrder(root);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写一个先去遍历的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			root.preOrder();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"空树不能遍历"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建赫夫曼树</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr 需要创建成赫夫曼树的数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 创建好后的根节点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//第一步为了操作方便</span></span><br><span class="line">		<span class="comment">/*1.遍历arr数组</span></span><br><span class="line"><span class="comment">		 * 2.将arr的每个元素构建成一个Node</span></span><br><span class="line"><span class="comment">		 * 3.将Node放入到ArrayList中</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> value:arr) &#123;</span><br><span class="line">			nodes.add(<span class="keyword">new</span> Node(value));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//排序，从小到大</span></span><br><span class="line">			Collections.sort(nodes);</span><br><span class="line">			System.out.println(<span class="string">"nodes="</span>+nodes);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//取出根节点权值最小的两颗二叉树</span></span><br><span class="line">			<span class="comment">//1.取出最小的节点</span></span><br><span class="line">			Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">			<span class="comment">//2.取出第2小的</span></span><br><span class="line">			Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line">			<span class="comment">//3.构建一颗新的二叉树</span></span><br><span class="line">			Node parent = <span class="keyword">new</span> Node(leftNode.value+rightNode.value);</span><br><span class="line">			parent.left = leftNode;</span><br><span class="line">			parent.right = rightNode;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//4.删除处理过得二叉树</span></span><br><span class="line">			nodes.remove(leftNode);</span><br><span class="line">			nodes.remove(rightNode);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//5.将parent加入到nodes</span></span><br><span class="line">			nodes.add(parent);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//返回赫夫曼树的root节点</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"><span class="comment">//为了让Node对象支持排序 Collections集合排序</span></span><br><span class="line"><span class="comment">//让Node实现Comparable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> value;<span class="comment">//节点权值</span></span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//表示从小到大</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.value-o.value;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//写一个前序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h1><h2 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol>
<li>赫夫曼编码也翻译为哈夫曼编码（Huffman Coding），又称霍夫曼编码，是一种编码方式，属于一种程序算法。</li>
<li>赫夫曼编码是赫夫曼树在电讯通信中的景点应用之一。</li>
<li>赫夫曼编码广泛用于数据文件压缩。其压缩率通常在20%~90%之间。</li>
<li>赫夫曼码是可变长编码（VLC)的一种。Huffman与1952年提出的一种编码方法，称之为最佳编码。</li>
</ol>
<h2 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h2><ol>
<li><p><strong>定长编码</strong><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%8101.png" alt=""></p>
</li>
<li><p><strong>变长编码</strong><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%8102.png" alt=""></p>
</li>
<li><p><strong>赫夫曼编码</strong><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%8103.png" style="zoom: 150%;" /></p>
</li>
</ol>
<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%8104.png" style="zoom: 67%;" />

<h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><h3 id="编写获取存放节点的集合方法"><a href="#编写获取存放节点的集合方法" class="headerlink" title="编写获取存放节点的集合方法"></a>编写获取存放节点的集合方法</h3><p>这里是把传入的字符串，统计其字符出现的次数，节点.data存放字符本身，节点.weight存放次数，也是权值。</p>
<p>然后把所有的节点放入到一个集合中，为下面创建赫夫曼树做准备。</p>
<p><strong>首先是节点类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建node</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt;</span>&#123;</span><br><span class="line">	Byte data;<span class="comment">//存放数据本身，比如 'a' 97</span></span><br><span class="line">	<span class="keyword">int</span> weight;<span class="comment">//权值，表示字符出现的次数</span></span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">		<span class="keyword">this</span>.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node arg0)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//从小到大</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.weight-arg0.weight;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Node [data="</span> + data + <span class="string">", weight="</span> + weight + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//前序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>把节点放到集合</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回list</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;Node&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//存储每个byte出现的次数 -》map</span></span><br><span class="line">		Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">byte</span> b: bytes) &#123;</span><br><span class="line">			Integer count = counts.get(b);</span><br><span class="line">			<span class="keyword">if</span>(count == <span class="keyword">null</span>) &#123;<span class="comment">//说明现在还没有数据</span></span><br><span class="line">				counts.put(b, <span class="number">1</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				counts.put(b, count+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//把每个键值对转成一个Node对象，并加入nodes集合</span></span><br><span class="line">		<span class="keyword">for</span>(Map.Entry&lt;Byte, Integer&gt; entry:counts.entrySet()) &#123;</span><br><span class="line">			nodes.add(<span class="keyword">new</span> Node(entry.getKey(),entry.getValue()));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> nodes;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="创建赫夫曼树"><a href="#创建赫夫曼树" class="headerlink" title="创建赫夫曼树"></a>创建赫夫曼树</h3><p>通过上面的节点集合创建赫夫曼树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建赫夫曼树</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(nodes.size()&gt;<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//排序 从小到大</span></span><br><span class="line">			Collections.sort(nodes);</span><br><span class="line">			<span class="comment">//取出第一颗最小的二叉树</span></span><br><span class="line">			Node leftNode = nodes.get(<span class="number">0</span>);</span><br><span class="line">			Node rightNode = nodes.get(<span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//创建一颗新的二叉树,根节点没有data，只有权值</span></span><br><span class="line">			Node parent = <span class="keyword">new</span> Node(<span class="keyword">null</span>,leftNode.weight+rightNode.weight);</span><br><span class="line">			parent.left = leftNode;</span><br><span class="line">			parent.right = rightNode;</span><br><span class="line">			<span class="comment">//将处理过的二叉树移除</span></span><br><span class="line">			nodes.remove(leftNode);</span><br><span class="line">			nodes.remove(rightNode);</span><br><span class="line">			<span class="comment">//将新的二叉树加入</span></span><br><span class="line">			nodes.add(parent);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成赫夫曼树对应的赫夫曼编码"><a href="#生成赫夫曼树对应的赫夫曼编码" class="headerlink" title="生成赫夫曼树对应的赫夫曼编码"></a>生成赫夫曼树对应的赫夫曼编码</h3><p>注意这里生成的赫夫曼编码虽然是0和1组成，但它还是一个字符串，没有转换成byte</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">	<span class="comment">//思路</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1.将赫夫曼编码表存放在Map&lt;Byte,String&gt;</span></span><br><span class="line"><span class="comment">	 * 2.在生成赫夫曼编码表时，需要去拼接路径，定义StringBuilder 存储某个叶子节点的路径</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="keyword">static</span> Map&lt;Byte,String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;Byte,String&gt;();</span><br><span class="line">	<span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 功能：将传入的node节点的所有叶子节点的赫夫曼编码存放到huffmanCodes集合中</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> node 传入节点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> code 路径：左子节点是0，右子节点1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node node,String code,StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">		StringBuilder stringBuilder2 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line">		<span class="comment">//将code加入到stringBuilder2</span></span><br><span class="line">		stringBuilder2.append(code);</span><br><span class="line">		<span class="keyword">if</span>(node!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//判断当前node是叶子节点还是非叶子节点</span></span><br><span class="line">			<span class="keyword">if</span>(node.data == <span class="keyword">null</span>) &#123;<span class="comment">//说明是非叶子节点</span></span><br><span class="line">				<span class="comment">//递归处理</span></span><br><span class="line">				<span class="comment">//向左</span></span><br><span class="line">				getCodes(node.left, <span class="string">"0"</span>, stringBuilder2);</span><br><span class="line">				<span class="comment">//向右递归</span></span><br><span class="line">				getCodes(node.right, <span class="string">"1"</span>, stringBuilder2);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;<span class="comment">//说明是叶子节点</span></span><br><span class="line">				huffmanCodes.put(node.data, stringBuilder2.toString());</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//为了调用方便重载一下</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte,String&gt; <span class="title">getCodes</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		getCodes(root.left, <span class="string">"0"</span>, stringBuilder);</span><br><span class="line">		getCodes(root.right, <span class="string">"1"</span>, stringBuilder);</span><br><span class="line">		<span class="keyword">return</span> huffmanCodes;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="得到一个赫夫曼编码表处理后的byte-数组"><a href="#得到一个赫夫曼编码表处理后的byte-数组" class="headerlink" title="得到一个赫夫曼编码表处理后的byte[]数组"></a>得到一个赫夫曼编码表处理后的byte[]数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个方法，将一个字符串对应的byte[]数组，通过生成的赫夫曼编码表返回一个赫夫曼编码表处理后的byte[]数组</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bytes 原始的字符串对应的byte[]</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> huffmanCode 生成的赫夫曼编码</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回赫夫曼编码处理后的byte[]</span></span><br><span class="line"><span class="comment">	 * 例如："i like like like java do you like a java"对应"1010100010111111....."这是字符串</span></span><br><span class="line"><span class="comment">	 * 把它变成byte[] 10101000(补码) =&gt;byte  【推导：10101000 =》 10101000-1=》10100111（反码）=》1101100】</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes,Map&lt;Byte,String&gt; huffmanCode) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 1.先利用huffmanCode 将bytes转成赫夫曼编码后的字符串</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//遍历bytes数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">byte</span> b:bytes) &#123;</span><br><span class="line">			stringBuilder.append(huffmanCode.get(b));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将字符串转成byte[]</span></span><br><span class="line">		<span class="comment">//统计返回的byte[] huffmannCodeBytes长度</span></span><br><span class="line">		<span class="comment">//int len = (stringBuilder.length()+7)/8;</span></span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">		<span class="keyword">if</span>(stringBuilder.length()%<span class="number">8</span>==<span class="number">0</span>) &#123;</span><br><span class="line">			len = stringBuilder.length()/<span class="number">8</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			len = stringBuilder.length()/<span class="number">8</span>+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创键存储压缩后的byte数组</span></span><br><span class="line">		<span class="keyword">byte</span>[] huffmannCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">		<span class="keyword">int</span> index=<span class="number">0</span>;<span class="comment">//记录是第几个byte</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;stringBuilder.length();i=i+<span class="number">8</span>) &#123;<span class="comment">//因为是每八位对应一个byte</span></span><br><span class="line">			String strByte;</span><br><span class="line">			<span class="keyword">if</span>(i+<span class="number">8</span>&gt;stringBuilder.length()) &#123;</span><br><span class="line">				strByte = stringBuilder.substring(i);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				strByte = stringBuilder.substring(i,i+<span class="number">8</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//将strByte转换成byte放入</span></span><br><span class="line">			huffmannCodeBytes[index] = (<span class="keyword">byte</span>)Integer.parseInt(strByte, <span class="number">2</span>);<span class="comment">//2代表进制</span></span><br><span class="line">			index++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> huffmannCodeBytes;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后将上方步骤进行封装"><a href="#最后将上方步骤进行封装" class="headerlink" title="最后将上方步骤进行封装"></a>最后将上方步骤进行封装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用一个方法，把前面的方法封装起来</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回的是经过赫夫曼编码处理后的字节数组（压缩后的）</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">		List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">		<span class="comment">//创建赫夫曼树</span></span><br><span class="line">		Node root = createHuffmanTree(nodes);</span><br><span class="line">		<span class="comment">//生成对应的赫夫曼编码</span></span><br><span class="line">		Map&lt;Byte,String&gt; huffmanCodes = getCodes(root);</span><br><span class="line">		<span class="keyword">byte</span>[] huffmanCodeBytes = zip(bytes,huffmanCodes);</span><br><span class="line">		<span class="keyword">return</span>     huffmanCodeBytes;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String content=<span class="string">"i like like like java do you like a java"</span>;</span><br><span class="line">		<span class="keyword">byte</span>[] contentBytes = content.getBytes();</span><br><span class="line">		<span class="keyword">byte</span>[] huffmanCodesBytes= huffmanZip(contentBytes);</span><br><span class="line">		System.out.println(Arrays.toString(huffmanCodesBytes));</span><br><span class="line">&#125;</span><br><span class="line">结果为：</span><br><span class="line">[-<span class="number">88</span>, -<span class="number">65</span>, -<span class="number">56</span>, -<span class="number">65</span>, -<span class="number">56</span>, -<span class="number">65</span>, -<span class="number">55</span>, <span class="number">77</span>, -<span class="number">57</span>, <span class="number">6</span>, -<span class="number">24</span>, -<span class="number">14</span>, -<span class="number">117</span>, -<span class="number">4</span>, -<span class="number">60</span>, -<span class="number">90</span>, <span class="number">28</span>]</span><br></pre></td></tr></table></figure>

<h2 id="数据解压"><a href="#数据解压" class="headerlink" title="数据解压"></a>数据解压</h2><p>解码过程就是编码的逆向操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 将一个byte转成二进制字符串</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> b 传入的byte</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> flag 表示是否补高位，true表示需要</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>  返回该byte对应的二进制字符串，注意是按补码返回</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteToBitString</span><span class="params">(<span class="keyword">boolean</span> flag,<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//使用一个变量保存b</span></span><br><span class="line">		<span class="keyword">int</span> temp  = b;</span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			<span class="comment">//如果是正数，补高位</span></span><br><span class="line">			temp |= <span class="number">256</span>;<span class="comment">//按位或256,1 0000 0000 | 0000 0001 =》1 0000 0001  </span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		String str = Integer.toBinaryString(temp);<span class="comment">//返回的是temp对应的二进制补码</span></span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			<span class="keyword">return</span> str.substring(str.length()-<span class="number">8</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> str;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解码</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> huffmanCodes 赫夫曼编码表</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> huffmanBytes 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 原来的字符串对应的数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte,String&gt; huffmanCodes,<span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">		<span class="comment">//1.先得到huffmanBytes 对应的二进制字符串</span></span><br><span class="line">		StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="comment">//将byte[] 转成二进制的字符串</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;huffmanBytes.length;i++) &#123;</span><br><span class="line">			<span class="keyword">byte</span> b = huffmanBytes[i];</span><br><span class="line">			<span class="keyword">boolean</span> flag = (i ==huffmanBytes.length-<span class="number">1</span>);</span><br><span class="line">			stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//System.out.println("赫夫曼字节数组对应的二进制字符串："+stringBuilder.toString());</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//把字符串按指定的赫夫曼编码进行解码</span></span><br><span class="line">		<span class="comment">//把赫夫曼编码表进行调换，因为要反向查询 a-&gt;100 现在是100-》a</span></span><br><span class="line">		Map&lt;String,Byte&gt; map = <span class="keyword">new</span> HashMap&lt;String,Byte&gt;();</span><br><span class="line">		<span class="keyword">for</span>(Map.Entry&lt;Byte, String&gt; entry:huffmanCodes.entrySet()) &#123;</span><br><span class="line">			map.put(entry.getValue(), entry.getKey());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//创建一个集合存放byte</span></span><br><span class="line">		List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stringBuilder.length();) &#123;</span><br><span class="line">			<span class="keyword">int</span> count = <span class="number">1</span>;<span class="comment">//小的计数器</span></span><br><span class="line">			<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">			Byte b = <span class="keyword">null</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span>(flag) &#123;</span><br><span class="line">				<span class="comment">//递增取出key</span></span><br><span class="line">				</span><br><span class="line">				String key = stringBuilder.substring(i,i+count);<span class="comment">//相当于i不动，count动，直到匹配到一个字符</span></span><br><span class="line">				b=map.get(key);</span><br><span class="line">				<span class="keyword">if</span>(b==<span class="keyword">null</span>) &#123;<span class="comment">//说明没有匹配到</span></span><br><span class="line">					count++;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;<span class="comment">//匹配到</span></span><br><span class="line">					flag =<span class="keyword">false</span>;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			list.add(b);</span><br><span class="line">			i+=count;<span class="comment">//直接移动到count位置</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当for循环结束后，我们list中就存放了所有字符</span></span><br><span class="line">		<span class="comment">//把list放入byte[]</span></span><br><span class="line">		<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;b.length;i++) &#123;</span><br><span class="line">			b[i] = list.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String content=<span class="string">"i like like like java do you like a java"</span>;</span><br><span class="line">		<span class="keyword">byte</span>[] contentBytes = content.getBytes();</span><br><span class="line">		<span class="keyword">byte</span>[] huffmanCodesBytes= huffmanZip(contentBytes);</span><br><span class="line">		System.out.println(Arrays.toString(huffmanCodesBytes));</span><br><span class="line">		<span class="keyword">byte</span>[] sourceBytes = decode(huffmanCodes, huffmanCodesBytes);</span><br><span class="line">		System.out.println(<span class="string">"原来的字符串="</span>+<span class="keyword">new</span> String(sourceBytes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实践-文件压缩与解压"><a href="#实践-文件压缩与解压" class="headerlink" title="实践-文件压缩与解压"></a>实践-文件压缩与解压</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个文件进行压缩</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> srcFile 传入的希望压缩文件的完整路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dstFile 压缩后将文件放到哪个目录下</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(String srcFile,String dstFile)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建输出流</span></span><br><span class="line">	OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">	ObjectOutputStream oos=<span class="keyword">null</span>;</span><br><span class="line">	FileInputStream is=<span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//创建文件的输入流</span></span><br><span class="line">		is = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">		<span class="comment">//创建一个和源文件大小一样的byte数组</span></span><br><span class="line">		<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">		<span class="comment">//读取文件</span></span><br><span class="line">		is.read(b);</span><br><span class="line">		<span class="comment">//对源文件压缩</span></span><br><span class="line">		<span class="keyword">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line">		<span class="comment">//创建文件输出流，存放压缩文件</span></span><br><span class="line">		os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">		<span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">		oos = <span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">		<span class="comment">//把赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">		oos.writeObject(huffmanBytes);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//这里以对象流的方式写入赫夫曼编码，是为了以后我们恢复源文件时使用</span></span><br><span class="line">		<span class="comment">//注意要把赫夫曼编码写入压缩文件</span></span><br><span class="line">		oos.writeObject(huffmanCodes);</span><br><span class="line">		</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		System.out.println(e.getMessage());</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123; 				</span><br><span class="line">			oos.close();</span><br><span class="line">			os.close();</span><br><span class="line">			is.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件解压</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">unZipFile</span><span class="params">(String zipFile,String dstFile)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//定义文件输入流</span></span><br><span class="line">		InputStream is = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//定义一个对象输入流</span></span><br><span class="line">		ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">//定义文件的输出流</span></span><br><span class="line">		OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//创建文件输入流</span></span><br><span class="line">			is =<span class="keyword">new</span> FileInputStream(zipFile);</span><br><span class="line">			<span class="comment">//创建一个和is关联的对象输入流</span></span><br><span class="line">			ois = <span class="keyword">new</span> ObjectInputStream(is);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//读取huffmanBytes</span></span><br><span class="line">			<span class="keyword">byte</span>[] huffmanBytes = (<span class="keyword">byte</span>[])ois.readObject();</span><br><span class="line">			<span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">			Map&lt;Byte,String&gt; codes =(Map&lt;Byte,String&gt;) ois.readObject();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//解码</span></span><br><span class="line">			<span class="keyword">byte</span>[] bytes = decode(codes, huffmanBytes);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//将bytes写入到目标文件</span></span><br><span class="line">			os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">			<span class="comment">//写出数据</span></span><br><span class="line">			os.write(bytes);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				os.close();</span><br><span class="line">				ois.close();</span><br><span class="line">				is.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				System.out.println(e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="赫夫曼编码压缩文件注意事项"><a href="#赫夫曼编码压缩文件注意事项" class="headerlink" title="赫夫曼编码压缩文件注意事项"></a>赫夫曼编码压缩文件注意事项</h2><ol>
<li>如果文件本省就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化，比如视屏，ppt等等文件。</li>
<li>赫夫曼编码是按字节来处理的，因此可以处理所有文件。</li>
<li>如果一个文件中的内容，重复数据不多，压缩效果也不会很明显。</li>
</ol>
<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><h2 id="先看一个需求"><a href="#先看一个需求" class="headerlink" title="先看一个需求"></a>先看一个需求</h2><p>给你一个数列（7,3,10,12,5,1,9），要求能够高效的完成对数据的查询和添加</p>
<h2 id="解决方案分析"><a href="#解决方案分析" class="headerlink" title="解决方案分析"></a>解决方案分析</h2><ol>
<li>使用<strong>数组</strong><ul>
<li>数组未排序，优点：直接在数组尾添加，速度快。缺点查找速度慢。</li>
<li>数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，再添加新数据时，找到插入位置后，后面的数据需要整体移动，速度慢。</li>
</ul>
</li>
<li>使用<strong>链式存储-链表</strong><ul>
<li>不管链表是否有序，查找速度都很慢，添加速度比数组快，不需要整体移动数据。</li>
</ul>
</li>
<li>使用<strong>二叉排序树</strong></li>
</ol>
<h2 id="二叉排序树介绍"><a href="#二叉排序树介绍" class="headerlink" title="二叉排序树介绍"></a>二叉排序树介绍</h2><p><strong>二叉排序树</strong>：BST(Binary Sort(Search) Tree)，对于二叉排序树的<strong>任何一个非叶子节点</strong>，要求<strong>左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。</strong></p>
<p><strong>特别说明</strong>：如果有相同的值，可以将该节点放在左子节点或右子节点。</p>
<p>比如针对前面的数据（7,3,10,12,5,1,9）对应的二叉排序树为：<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%B8%BE%E4%BE%8B.png" alt=""></p>
<h2 id="二叉树的创建和遍历"><a href="#二叉树的创建和遍历" class="headerlink" title="二叉树的创建和遍历"></a>二叉树的创建和遍历</h2><h3 id="首先创建节点类"><a href="#首先创建节点类" class="headerlink" title="首先创建节点类"></a>首先创建节点类</h3><p>这里面有一个中序遍历方法，下面我们在加入add方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>添加节点</strong></p>
<p>思路：</p>
<ol>
<li>首先判断加入的节点是不是空，是空就直接返回。</li>
<li>不是空的话，根据二叉排序树的特点，我们应该使要加入节点的值与当前节点的值进行比较。</li>
<li>加入节点的值大于当前节点的值，要放在右子树</li>
<li>加入节点的值小于当前节点的值，要放在左子树</li>
<li>所以去递归找位置即可</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加节点</span></span><br><span class="line">	<span class="comment">//递归形式添加节点，满足二叉排序树</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断传入节点的值和当前子树的根节点关系</span></span><br><span class="line">		<span class="keyword">if</span>(node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;<span class="comment">//如果当前节点左子节点为空</span></span><br><span class="line">				<span class="keyword">this</span>.left = node;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.left.add(node);<span class="comment">//递归向左子树添加</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.right =node;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.right.add(node);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建二叉排序树"><a href="#创建二叉排序树" class="headerlink" title="创建二叉排序树"></a>创建二叉排序树</h3><p>在这里面去调用上面node类里的add和中序遍历方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Node root;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">			root = node;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			root.add(node);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			root.infixOrder();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"空树无法遍历"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h2><p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑</p>
<ol>
<li><strong>删除叶子节点</strong></li>
<li>删除<strong>只有一颗子树的节点</strong></li>
<li>删除<strong>有两颗子树的节点</strong></li>
</ol>
<h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p><strong>第一种情况：删除叶子节点</strong></p>
<ol>
<li>需要先去找到要删除的节点 targetNode.</li>
<li>然后找到targetNode的父节点parent</li>
<li>确定targetNode是parent的左子节点还是右子节点</li>
<li>根据前面的情况来对应删除<ul>
<li>左子节点 parent.left = null;</li>
<li>右子节点 parent.right = null;</li>
</ul>
</li>
</ol>
<p><strong>第二种情况：删除只有一颗子树的节点</strong></p>
<ol>
<li>需要先去找到要删除的节点 targerNode</li>
<li>找到targetNode的父节点parent</li>
<li>确定parent的子节点是左子节点还是右子节点</li>
<li>确定targetNode是parent的左子节点还是右子节点</li>
<li>如果targetNode有左子节点<ol>
<li>如果targetNode是parent的左子节点<ul>
<li>parent.left = targetNode.left</li>
</ul>
</li>
<li>如果targetNode是parent的右子节点<ul>
<li>parent.right = targetNode.left</li>
</ul>
</li>
</ol>
</li>
<li>如果targetNode有右子节点<ol>
<li>如果targetNode是parent的左子节点<ul>
<li>parent.left = target.right</li>
</ul>
</li>
<li>如果targetNode是parent的右子节点<ul>
<li>parent.right = targetNode.right</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><strong>第三种情况：删除有两颗子树的节点</strong></p>
<ol>
<li>需要先去找到要删除的节点 targetNode</li>
<li>找到targetNode的父节点parent</li>
<li>从targetNode的右子树找到最小的节点（或者从左子树找到最大的节点）</li>
<li>用一个临时变量，将最小节点的值保存</li>
<li>删除该最小节点</li>
<li>targetNode.value = 临时变量</li>
</ol>
<h3 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>首先在Node节点类中加入两个方法</strong></p>
<p>1.查找要删除的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找要删除的节点</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> value 希望删除的节点的值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 如果找到，返回该节点，否则返回null</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(value == <span class="keyword">this</span>.value) &#123;<span class="comment">//说明找到</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(value&lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//如果查找的值，小于当前节点，向左子树递归查找</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.left==<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;<span class="comment">//大于</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>2.查找要删除节点的父节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找要删除节点的父节点</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> value 要找的节点的值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回要删除节点的父节点，没有返回null</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>((<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value==value) || (<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value==value)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//如果查找的值小于当前节点的值，并且当前节点的左子节点不为空</span></span><br><span class="line">			<span class="keyword">if</span>(value&lt;<span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然后在二叉排序树中加入它们的调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找要删除节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> root.search(value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找要删除节点的父节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>第三种情况有删除最小值节点，所以在加入一个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 当做二叉排序树的根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 以node为根节点的二叉排序树的最小节点的值，删除它</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">	Node target = node;</span><br><span class="line">	<span class="comment">//循环查找左节点,就会找到最小值</span></span><br><span class="line">	<span class="keyword">while</span>(target.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">		target = target.left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这时target就指向了最小节点</span></span><br><span class="line">	<span class="comment">//删除最小节点</span></span><br><span class="line">	delNode(target.value);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> target.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编写删除节点方法</strong></p>
<p>这里的代码与上面的思路分析是一致的。</p>
<p>要注意的一点是：删除只有一颗子树的节点，如果这个节点是根节点，那它是没有父节点的，这里要判断一下，对应下面34与47行，如果它是根节点的话，只需要把它的左子节点或右子节点变为根就OK了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//1.需要先去找到要删除的节点</span></span><br><span class="line">			Node targetNode = search(value);</span><br><span class="line">			<span class="comment">//如果没有找到删除的节点</span></span><br><span class="line">			<span class="keyword">if</span>(targetNode==<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//如果我们发现当前这颗二叉排序树只有一个节点</span></span><br><span class="line">			<span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">				root = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//去查找targetNode的父节点</span></span><br><span class="line">			Node parent = searchParent(value);</span><br><span class="line">			<span class="comment">//如果要删除的节点是叶子节点</span></span><br><span class="line">			<span class="keyword">if</span>(targetNode.left==<span class="keyword">null</span> &amp;&amp; targetNode.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">//判断targetNode是父节点的左子节点还是右子节2点</span></span><br><span class="line">				<span class="keyword">if</span>(parent.left!=<span class="keyword">null</span> &amp;&amp; parent.left.value==value) &#123;</span><br><span class="line">					parent.left=<span class="keyword">null</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(parent.right!=<span class="keyword">null</span> &amp;&amp; parent.right.value==value) &#123;</span><br><span class="line">					parent.right=<span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(targetNode.left!=<span class="keyword">null</span> &amp;&amp; targetNode.right!=<span class="keyword">null</span>) &#123;<span class="comment">//删除有两颗子树的节点</span></span><br><span class="line">				<span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">				targetNode.value = minVal;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;<span class="comment">//删除有一颗子树的节点</span></span><br><span class="line">				<span class="comment">//如果要删除的节点有左子节点</span></span><br><span class="line">				<span class="keyword">if</span>(targetNode.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span>(parent!=<span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="comment">//如果targetNode是parent的左子节点</span></span><br><span class="line">						<span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">							parent.left = targetNode.left;</span><br><span class="line">						&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="comment">//说明是parent的右子节点</span></span><br><span class="line">							parent.right = targetNode.left;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						root = targetNode.left;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;<span class="comment">//要删除的节点有右子节点</span></span><br><span class="line">					<span class="keyword">if</span>(parent!=<span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="comment">//如果trgetNode是parent的左子节点</span></span><br><span class="line">						<span class="keyword">if</span>(parent.left.value==value) &#123;</span><br><span class="line">							parent.left = targetNode.right;</span><br><span class="line">						&#125;<span class="keyword">else</span> &#123;<span class="comment">//trgetNode是parent的右子节点</span></span><br><span class="line">							parent.right = targetNode.right;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						root = targetNode.right;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二叉平衡树（AVL树）"><a href="#二叉平衡树（AVL树）" class="headerlink" title="二叉平衡树（AVL树）"></a>二叉平衡树（AVL树）</h1><h2 id="二叉排序树可能的问题"><a href="#二叉排序树可能的问题" class="headerlink" title="二叉排序树可能的问题"></a>二叉排序树可能的问题</h2><p>给你一个数列{1,2,3,4,5,6}要求创建一颗二叉排序树（BST）并分析问题所在。</p>
<p><strong>左边BST存在的问题分析</strong>：</p>
<ol>
<li>左子树全部为空，从形式上看，更像一个单链表。</li>
<li>插入速度没有影响。</li>
<li>查询速度明显降低（因为需要一次比较），不能发挥BST的有时，因为每次还需要比较左子树，其查询速度比单链表还慢。</li>
<li>解决方案-平衡二叉树（AVL）</li>
</ol>
<h2 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol>
<li>平衡二叉树也叫平衡<strong>二叉搜索树</strong>又被称为AVL树，可以保证查询效率较高。</li>
<li>具有以下特点：它是<strong>一颗空树</strong>或<strong>它的左右两个子树的高度差的绝对值不超过1</strong>，并且<strong>左右两个子树都是一颗平衡二叉树</strong>。平衡二叉树的常用实现方法有红黑树，AVL,等等</li>
</ol>
<h2 id="应用案例–单旋转（右旋转）"><a href="#应用案例–单旋转（右旋转）" class="headerlink" title="应用案例–单旋转（右旋转）"></a>应用案例–单旋转（右旋转）</h2><p>要求：给你一个数列，创建出对应的平衡二叉树，数列{10,12,8,9,7,6}<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL01.png" style="zoom:50%;" /></p>
<p>由此看出，当插入6这个节点时，左子树高度为3，右子树高度为1,3-1=2&gt;1，此时已经不是AVL数了。</p>
<p>这时候我们要右旋转，来保持平衡。</p>
<p><strong>步骤</strong></p>
<ol>
<li>创建一颗新的节点newNode,值等于根节点的值</li>
<li>把新节点的右子树设置成当前节点的右子树 <code>newNode.right=right</code></li>
<li>把新节点的左子树设置为当前节点的左子树的右子树。<code>newNode.left=this.left.right</code></li>
<li>把当前节点的值换为左子节点的值 <code>value=left.value</code></li>
<li>把当前节点的左子树设置成左子树的左子树 <code>left = left.left</code></li>
<li>把当前节点的右子树设置为新节点 <code>this.right = newNode</code></li>
</ol>
<p><strong>图解</strong></p>
<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL%E5%8F%B3%E6%97%8B%E8%BD%AC.png" style="zoom:150%;" />



<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">		newNode.right = <span class="keyword">this</span>.right;</span><br><span class="line">		newNode.left = <span class="keyword">this</span>.left.right;</span><br><span class="line">		<span class="keyword">this</span>.value = <span class="keyword">this</span>.left.value;</span><br><span class="line">		<span class="keyword">this</span>.left = <span class="keyword">this</span>.left.left;</span><br><span class="line">		right = newNode;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="应用案例–单旋转（左旋转）"><a href="#应用案例–单旋转（左旋转）" class="headerlink" title="应用案例–单旋转（左旋转）"></a>应用案例–单旋转（左旋转）</h2><p>要求：给你个数列，创建出对应的平衡二叉树，数列{4,3,6,5,7,8}<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL02.png" style="zoom: 50%;" /></p>
<p>由此看出，当我们插入8这个节点时，它的左子树高度为1，右子树高度为3,3-1=2&gt;1</p>
<p>此时我们应该向左旋转以维持平衡。</p>
<p><strong>步骤</strong></p>
<ol>
<li>创建新节点，值为当前节点的值。</li>
<li>设置新节点的左子树为当前节点的左子树。<code>newNode.left=this.left</code></li>
<li>设置新节点的右子树为当前节点右子树的左子树。<code>newNode.right = this.right.left</code></li>
<li>把当前节点的值换为右子节点的值。<code>this.value = this.right.value</code></li>
<li>把当前节点的右子树设置为右子树的右子树。<code>this.right = this.right.right</code></li>
<li>把当前节点的左子树设置为新节点。<code>this.left = newNode</code></li>
</ol>
<p><strong>图解</strong></p>
<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL%E5%B7%A6%E6%97%8B%E8%BD%AC.png" style="zoom:150%;" />

<p><strong>代码实现</strong></p>
<p>将下面代码放入Node节点类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋转</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//以当前根节点的值，创建新节点</span></span><br><span class="line">		Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">		<span class="comment">//把新的节点的左子树，设置成当前节点的左子树</span></span><br><span class="line">		newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line">		<span class="comment">//把新的节点的右子树，设置成当前节点的右子树的左子树</span></span><br><span class="line">		newNode.right = <span class="keyword">this</span>.right.left;</span><br><span class="line">		<span class="comment">//把当前节点的值，替换成右子节点的值</span></span><br><span class="line">		<span class="keyword">this</span>.value =right.value;</span><br><span class="line">		<span class="comment">//把当前节点的右子树，设置成当前的点右子树的右子树</span></span><br><span class="line">		<span class="keyword">this</span>.right =<span class="keyword">this</span>.right.right;</span><br><span class="line">		<span class="comment">//把当前节点的左子树（左子节点）设置成新的节点</span></span><br><span class="line">		<span class="keyword">this</span>.left  = newNode;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="应用案例双旋转"><a href="#应用案例双旋转" class="headerlink" title="应用案例双旋转"></a>应用案例双旋转</h2><p>前面两个数列，进行单旋转（即一次旋转）就可以将非平衡二叉树转成平衡二叉树，但是在某些情况下，单旋转不能完成平衡二叉树的转换。比如：</p>
<h3 id="第一种情况：满足右旋转，并且当前节点左子树的右子树高度，大于左子树高度"><a href="#第一种情况：满足右旋转，并且当前节点左子树的右子树高度，大于左子树高度" class="headerlink" title="第一种情况：满足右旋转，并且当前节点左子树的右子树高度，大于左子树高度"></a>第一种情况：满足右旋转，并且当前节点左子树的右子树高度，大于左子树高度</h3><p><code>int[] arr={10,11,7,6,8,9}</code></p>
<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL%E5%8F%8C%E6%97%8B%E8%BD%AC%E5%8F%B3%E6%97%8B%E8%BD%AC%E4%B8%8D%E6%88%90%E7%AB%8B.png" style="zoom:50%;" />

<p>由上图我们可以看出，在右旋转之后，并没有使树平衡。</p>
<p><strong>解决思路</strong></p>
<ol>
<li>先对当前节点的左节点进行左旋转。</li>
<li>然后再对当前节点进行右旋转。</li>
</ol>
<p><strong>图解</strong></p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL%E5%85%88%E5%B7%A6%E5%90%8E%E5%8F%B3.png" alt=""></p>
<h3 id="第二种情况：满足左旋转，当前节点右子树的左子树高度，大于右子树高度"><a href="#第二种情况：满足左旋转，当前节点右子树的左子树高度，大于右子树高度" class="headerlink" title="第二种情况：满足左旋转，当前节点右子树的左子树高度，大于右子树高度"></a>第二种情况：满足左旋转，当前节点右子树的左子树高度，大于右子树高度</h3><p>int[] arr={2,1,6,5,7,3}</p>
<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL%E5%8F%8C%E6%97%8B%E8%BD%AC%E5%B7%A6%E6%97%8B%E8%BD%AC%E4%B8%8D%E6%88%90%E7%AB%8B.png" style="zoom: 50%;" />

<p>由图可知，左旋转之后，树并没有平衡。</p>
<p><strong>解决思路</strong></p>
<ol>
<li>先对当前节点右节点进行右旋转。</li>
<li>然后对当前节点进行左旋转。</li>
</ol>
<p><strong>图解</strong></p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/AVL%E5%85%88%E5%8F%B3%E5%90%8E%E5%B7%A6.png" alt=""></p>
<p>以上便是所有情况，我们在加入节点使，进行判断使树一直保持平衡就行了。</p>
<h2 id="应用案例代码整合"><a href="#应用案例代码整合" class="headerlink" title="应用案例代码整合"></a>应用案例代码整合</h2><p><strong>首先，怎么旋转是根据左子树与右子树的高度来决定的。</strong></p>
<p>因此我们先别一个方法求<strong>以当前节点为根节点的这棵树的高度</strong>。</p>
<p>这里使用了递归，树的高度就是左边或右边比较大的那个。这里巧就巧在最后的+1上。可以仔细理解一下！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回以当前节点为根节点的这棵树的高度</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Math.max(left==<span class="keyword">null</span>?<span class="number">0</span>:left.height(),right==<span class="keyword">null</span>?<span class="number">0</span>:right.height())+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是求左子树和右子树高度的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回左子树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left==<span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> left.height();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回右子树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(right==<span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> right.height();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>最终整合代码</strong></p>
<p>这其中关于怎么旋转的调用，放到Node类的add方法最后。也就是每加入一个节点，就判断一下它是不是导致不平衡了，然后进行相应的旋转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> avl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVLTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//int[] arr = &#123;4,3,6,5,7,8&#125;;</span></span><br><span class="line">		<span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">12</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">		AVLTree tree = <span class="keyword">new</span> AVLTree();</span><br><span class="line">		<span class="comment">//添加节点</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			tree.add(<span class="keyword">new</span> Node(arr[i]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//中序遍历</span></span><br><span class="line">		tree.infixOrder();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//在没有旋转之前</span></span><br><span class="line">		System.out.println(<span class="string">"在没有平衡处理后"</span>);</span><br><span class="line">		System.out.println(<span class="string">"树的高度："</span>+tree.getRoot().height());</span><br><span class="line">		System.out.println(<span class="string">"左子树高度："</span>+tree.getRoot().leftHeight());</span><br><span class="line">		System.out.println(<span class="string">"右子树高度"</span>+tree.getRoot().rightHeight());</span><br><span class="line">		System.out.println(tree.getRoot());</span><br><span class="line">		System.out.println(tree.getRoot().right);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//树</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">			root = node;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			root.add(node);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			root.infixOrder();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"空树无法遍历"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找要删除节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> root.search(value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找要删除节点的父节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//编写一个方法</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> node 当做二叉排序树的根节点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 以node为根节点的二叉排序树的最小节点的值，删除它</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		Node target = node;</span><br><span class="line">		<span class="comment">//循环查找左节点,就会找到最小值</span></span><br><span class="line">		<span class="keyword">while</span>(target.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			target = target.left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这时target就指向了最小节点</span></span><br><span class="line">		<span class="comment">//删除最小节点</span></span><br><span class="line">		delNode(target.value);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> target.value;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//删除节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//1.需要先去找到要删除的节点</span></span><br><span class="line">			Node targetNode = search(value);</span><br><span class="line">			<span class="comment">//如果没有找到删除的节点</span></span><br><span class="line">			<span class="keyword">if</span>(targetNode==<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//如果我们发现当前这颗二叉排序树只有一个节点</span></span><br><span class="line">			<span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">				root = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//去查找targetNode的父节点</span></span><br><span class="line">			Node parent = searchParent(value);</span><br><span class="line">			<span class="comment">//如果要删除的节点是叶子节点</span></span><br><span class="line">			<span class="keyword">if</span>(targetNode.left==<span class="keyword">null</span> &amp;&amp; targetNode.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">//判断targetNode是父节点的左子节点还是右子节点</span></span><br><span class="line">				<span class="keyword">if</span>(parent.left!=<span class="keyword">null</span> &amp;&amp; parent.left.value==value) &#123;</span><br><span class="line">					parent.left=<span class="keyword">null</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(parent.right!=<span class="keyword">null</span> &amp;&amp; parent.right.value==value) &#123;</span><br><span class="line">					parent.right=<span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(targetNode.left!=<span class="keyword">null</span> &amp;&amp; targetNode.right!=<span class="keyword">null</span>) &#123;<span class="comment">//删除有两颗子树的节点</span></span><br><span class="line">				<span class="keyword">int</span> minVal = delRightTreeMin(targetNode.right);</span><br><span class="line">				targetNode.value = minVal;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;<span class="comment">//删除有一颗子树的节点</span></span><br><span class="line">				<span class="comment">//如果要删除的节点有左子节点</span></span><br><span class="line">				<span class="keyword">if</span>(targetNode.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span>(parent!=<span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="comment">//如果targetNode是parent的左子节点</span></span><br><span class="line">						<span class="keyword">if</span>(parent.left.value == value) &#123;</span><br><span class="line">							parent.left = targetNode.left;</span><br><span class="line">						&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="comment">//说明是parent的右子节点</span></span><br><span class="line">							parent.right = targetNode.left;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						root = targetNode.left;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;<span class="comment">//要删除的节点有右子节点</span></span><br><span class="line">					<span class="keyword">if</span>(parent!=<span class="keyword">null</span>) &#123;</span><br><span class="line">						<span class="comment">//如果trgetNode是parent的左子节点</span></span><br><span class="line">						<span class="keyword">if</span>(parent.left.value==value) &#123;</span><br><span class="line">							parent.left = targetNode.right;</span><br><span class="line">						&#125;<span class="keyword">else</span> &#123;<span class="comment">//trgetNode是parent的右子节点</span></span><br><span class="line">							parent.right = targetNode.right;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						root = targetNode.right;</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回左子树的高度</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(left==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> left.height();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回右子树的高度</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(right==<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> right.height();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回以当前节点为根节点的这棵树的高度</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Math.max(left==<span class="keyword">null</span>?<span class="number">0</span>:left.height(),right==<span class="keyword">null</span>?<span class="number">0</span>:right.height())+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//左旋转</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//以当前根节点的值，创建新节点</span></span><br><span class="line">		Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">		<span class="comment">//把新的节点的左子树，设置成当前节点的左子树</span></span><br><span class="line">		newNode.left = <span class="keyword">this</span>.left;</span><br><span class="line">		<span class="comment">//把新的节点的右子树，设置成当前节点的右子树的左子树</span></span><br><span class="line">		newNode.right = <span class="keyword">this</span>.right.left;</span><br><span class="line">		<span class="comment">//把当前节点的值，替换成右子节点的值</span></span><br><span class="line">		<span class="keyword">this</span>.value =right.value;</span><br><span class="line">		<span class="comment">//把当前节点的右子树，设置成当前的点右子树的右子树</span></span><br><span class="line">		<span class="keyword">this</span>.right =<span class="keyword">this</span>.right.right;</span><br><span class="line">		<span class="comment">//把当前节点的左子树（左子节点）设置成新的节点</span></span><br><span class="line">		<span class="keyword">this</span>.left  = newNode;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//右旋转</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Node newNode = <span class="keyword">new</span> Node(<span class="keyword">this</span>.value);</span><br><span class="line">		newNode.right = <span class="keyword">this</span>.right;</span><br><span class="line">		newNode.left = <span class="keyword">this</span>.left.right;</span><br><span class="line">		<span class="keyword">this</span>.value = <span class="keyword">this</span>.left.value;</span><br><span class="line">		<span class="keyword">this</span>.left = <span class="keyword">this</span>.left.left;</span><br><span class="line">		right = newNode;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加节点</span></span><br><span class="line">	<span class="comment">//递归形式添加节点，满足二叉排序树</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断传入节点的值和当前子树的根节点关系</span></span><br><span class="line">		<span class="keyword">if</span>(node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;<span class="comment">//如果当前节点左子节点为空</span></span><br><span class="line">				<span class="keyword">this</span>.left = node;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.left.add(node);<span class="comment">//递归向左子树添加</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.right =node;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.right.add(node);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//当添加完一个节点后，如果右子树的高度-左子树的高度&gt;1,左旋转</span></span><br><span class="line">		<span class="keyword">if</span>(rightHeight()-leftHeight()&gt;<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树高度</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.leftHeight() &gt; <span class="keyword">this</span>.right.rightHeight()) &#123;</span><br><span class="line">				<span class="comment">//先对右子节点进行右旋转</span></span><br><span class="line">				right.rightRotate();</span><br><span class="line">				<span class="comment">//然后再对当前节点进行左旋转</span></span><br><span class="line">				leftRotate();</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				leftRotate();<span class="comment">//左旋转</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;<span class="comment">//这里处理完就结束，不往下判断</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//当添加完一个节点后，如果（左子树高度-右子树高度）&gt;1,右旋转</span></span><br><span class="line">		<span class="keyword">if</span>(leftHeight()-rightHeight()&gt;<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">//如果它的左子树的右子树的高度大于它的左子树的左子树高度</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.rightHeight() &gt; <span class="keyword">this</span>.left.leftHeight()) &#123;</span><br><span class="line">				<span class="comment">//先对当前节点的左节点（左子树）进行左旋转</span></span><br><span class="line">				left.leftRotate();</span><br><span class="line">				<span class="comment">//在对当前节点进行右旋转</span></span><br><span class="line">				rightRotate();</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;<span class="comment">//不满足就直接进行右旋转</span></span><br><span class="line">				rightRotate();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找要删除的节点</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> value 希望删除的节点的值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 如果找到，返回该节点，否则返回null</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(value == <span class="keyword">this</span>.value) &#123;<span class="comment">//说明找到</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(value&lt;<span class="keyword">this</span>.value) &#123;<span class="comment">//如果查找的值，小于当前节点，向左子树递归查找</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.left==<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;<span class="comment">//大于</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.right==<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//查找要删除节点的父节点</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> value 要找的节点的值</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 返回要删除节点的父节点，没有返回null</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>((<span class="keyword">this</span>.left!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value==value) || (<span class="keyword">this</span>.right!=<span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value==value)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//如果查找的值小于当前节点的值，并且当前节点的左子节点不为空</span></span><br><span class="line">			<span class="keyword">if</span>(value&lt;<span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">this</span>.left.searchParent(value);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right!=<span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">this</span>.right.searchParent(value);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="多路查找树"><a href="#多路查找树" class="headerlink" title="多路查找树"></a>多路查找树</h1><h2 id="二叉树的问题"><a href="#二叉树的问题" class="headerlink" title="二叉树的问题"></a>二叉树的问题</h2><ol>
<li>二叉树需要加载到内存，如果二叉树节点少，没什么问题，但如果二叉树的节点很多，就存在如下问题：<ol>
<li>问题1：在构建二叉树时，需要多次进行i/o操作（海量数据存在数据库或文件中），节点海量，构建二叉树时速度有影响。</li>
<li>问题2：节点海量，也会造成二叉树的高度很大，会降低操作速度。</li>
</ol>
</li>
</ol>
<h2 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h2><ol>
<li>在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树。</li>
<li>2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能对二叉树惊醒优化。</li>
<li>举例</li>
</ol>
<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%A4%9A%E5%8F%89%E6%A0%91%E4%B8%BE%E4%BE%8B.png" style="zoom:67%;" />

<h2 id="B树的基本介绍"><a href="#B树的基本介绍" class="headerlink" title="B树的基本介绍"></a>B树的基本介绍</h2><p>B树通过重新组织节点，降低树的高度，并且减少i/o读写次数来提升效率。<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/B%E6%A0%91%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D.png" alt=""></p>
<ol>
<li>如图B树通过重新组织节点，降低了树的高度。</li>
<li>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页（页得大小通常为4K），这样每个节点只需要一次I/O就可以完全载入。</li>
<li>将树的度M设置为124，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素，B树（B+）广泛应用于文件存储系统以及数据库系统中。</li>
</ol>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p><strong>2-3树是最简单的B树结构，具有如下特点：</strong></p>
<ol>
<li>2-3树的所有叶子节点都在同一层（只要是B树都满足这个条件）</li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点。</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点。</li>
<li>2-3树是由二节点和三节点构成的树。</li>
</ol>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>将数列{16,24,12,32,14,26,34,10,8,28,38,20}构建成2-3树，并保证数据插入的大小顺序。</p>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/2-3%E6%A0%91.png" alt=""></p>
<h1 id="B树，B-树和B-树"><a href="#B树，B-树和B-树" class="headerlink" title="B树，B+树和B*树"></a>B树，B+树和B*树</h1><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/B%E6%A0%91.png" alt=""></p>
<p>说明：</p>
<ol>
<li>B树的阶：节点的最多子节点个数。比如2-3树的阶是3,  2-3-4树的阶是4.</li>
<li>B-树的搜索，从根节点开始，对节点内的关键字（有序）序列进行二分查找，如果命中则结束，否则紧促查询关键字所属范围的儿子节点；重读，知道所对应的儿子指针为空，或已经是叶子节点。</li>
<li>关键字集合分布在整棵树中，即叶子节点和非叶子节点都存放数据。</li>
<li>搜索有可能在非叶子节点结束。</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找。</li>
</ol>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是B树的变体，也是多路搜索树。</p>
<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/B%2B%E6%A0%91.png" style="zoom:80%;" />

<p>说明：</p>
<ol>
<li>B+树的搜索与B树也基本相同，区别是B+树只有达到叶子节点才命中（B树可以在非叶子节点），其性能也等价于在关键字全集做一次二分查找。</li>
<li>所有关键字都出现在叶子节点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字（数据）恰好是有序的。</li>
<li>不可能在非叶子节点命中。</li>
<li>非叶子节点相当于是叶子节点的索引（稀疏索引），叶子节点相当于存储（关键字）数据的数据层。</li>
<li>更适合文建索引系统</li>
<li>B树和B+树各有各自的应用场景。</li>
</ol>
<h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><p>B*树是B+树的变体，在B+树的非根和非叶子节点再增加指向兄弟的指针。</p>
<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/B%E6%98%9F%E6%A0%91.png" style="zoom:80%;" />

<p>说明：</p>
<ol>
<li><code>B*</code>树定义了非叶子节点关键字个数至少为<code>（2/3）*M</code>,而B+树的块的最低使用率为的1/2.</li>
<li>从第1个特点我们可以看出，B*树分配新节点的概率比B+树要低，空间使用率更高。</li>
</ol>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h2><h3 id="为什么要有图"><a href="#为什么要有图" class="headerlink" title="为什么要有图"></a>为什么要有图</h3><ol>
<li>前面我们学了线性表和树</li>
<li>线性表局限于一个直接前驱和一个直接后驱的关系</li>
<li>树也只能有一个直接前驱也就是父节点</li>
<li>放我们需要<strong>表示多对多</strong>的关系时，这里我们就用到了图</li>
</ol>
<h3 id="图的举例"><a href="#图的举例" class="headerlink" title="图的举例"></a>图的举例</h3><p>图是一种<strong>数据结构</strong>，其中节点可以具有零个或多个相邻元素。两个节点直接按的连接称为边。节点也可以称为顶点。如图：<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E5%9B%BE.png" alt=""></p>
<h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><ol>
<li><p>顶点（vertex）</p>
</li>
<li><p>边（edge）</p>
</li>
<li><p>路径</p>
</li>
<li><p>无向图<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%97%A0%E5%90%91%E5%9B%BE.png" style="zoom:50%;" /></p>
</li>
<li><p>有向图</p>
</li>
<li><p>带权图<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E6%9C%89%E5%90%91%E5%9B%BE%E5%92%8C%E5%B8%A6%E6%9D%83%E5%9B%BE.png" style="zoom:50%;" /></p>
</li>
</ol>
<h2 id="图的表示方式"><a href="#图的表示方式" class="headerlink" title="图的表示方式"></a>图的表示方式</h2><p>图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n各顶点的图而言，矩阵的row和col表示的是1…n个点。<img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt=""></p>
<p>例如：1和0连接，那么(1,0)=1  (0,1)=1</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><ol>
<li>邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在的，会造成空间的一定损失。</li>
<li>邻接表的实现之关系存在的边，不关心不存在的边。因此没有空间良妃，邻接表有数组+链表组成</li>
</ol>
<p><img src="https://hexolee.oss-cn-beijing.aliyuncs.com/hexo/shujujiegou/%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt=""></p>
<h2 id="图的快速入门"><a href="#图的快速入门" class="headerlink" title="图的快速入门"></a>图的快速入门</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="comment">//存储顶点</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[][] edges;<span class="comment">//存储图的对应的邻接矩阵</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> numOfEdges;<span class="comment">//表示边个数</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//定义数组boolean[] 记录某个节点是否被访问</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">		String VertexValue[] = &#123;<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>&#125;;</span><br><span class="line">		<span class="comment">//创建图对象</span></span><br><span class="line">		Graph graph= <span class="keyword">new</span> Graph(n);</span><br><span class="line">		<span class="comment">//循环添加顶点</span></span><br><span class="line">		<span class="keyword">for</span>(String value:VertexValue) &#123;</span><br><span class="line">			graph.insertVertex(value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//添加边  A-B,A-C,B-C,B-D,B-E</span></span><br><span class="line">		graph.insertEdge(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		graph.insertEdge(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">		graph.insertEdge(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//显示一把</span></span><br><span class="line">		graph.showGraph();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">		edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">		vertexList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		numOfEdges = <span class="number">0</span>;</span><br><span class="line">		isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//图中常用方法</span></span><br><span class="line">	<span class="comment">//返回节点个数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vertexList.size();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回边的树目</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> numOfEdges;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回节点i对应的数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vertexList.get(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//返回v1和v2的权值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示图对应的矩阵</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span>[] link:edges) &#123;</span><br><span class="line">			System.out.println(Arrays.toString(link));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//插入节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">		vertexList.add(vertex);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加边</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> v1 第一个点的下标，即第几个顶点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> v2 第二个点</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> weight 权值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2,<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">		edges[v1][v2] = weight;</span><br><span class="line">		edges[v2][v1] = weight;</span><br><span class="line">		numOfEdges++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图的深度优先遍历"><a href="#图的深度优先遍历" class="headerlink" title="图的深度优先遍历"></a>图的深度优先遍历</h2><h3 id="图遍历介绍"><a href="#图遍历介绍" class="headerlink" title="图遍历介绍"></a>图遍历介绍</h3><p>所谓图的遍历，即是对节点的访问。一个图有那么多个节点，如果遍历这些节点，需要特定策略，一般有两种：深度优先遍历和广度优先遍历。</p>
<h3 id="深度优先遍历基本思想"><a href="#深度优先遍历基本思想" class="headerlink" title="深度优先遍历基本思想"></a>深度优先遍历基本思想</h3><p>图的深度优先搜索（DFS(Depth First Search)）</p>
<ol>
<li>深度优先遍历，从初始访问节点触发，初始访问节点可能有多个邻接节点，深度优先遍历的策略就是首先访问第一个邻接节点，然后在以这个被访问的邻接节点作为初始节点，访问它的第一个邻接节点。可以这样理解：每次都在访问完当前节点后首先访问当前节点的第一邻接节点。</li>
<li>我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个节点的所有邻接节点进行横向访问。</li>
<li>显然，深度优先搜索是一个递归的过程。</li>
</ol>
<h3 id="深度优先遍历算法步骤"><a href="#深度优先遍历算法步骤" class="headerlink" title="深度优先遍历算法步骤"></a>深度优先遍历算法步骤</h3><ol>
<li>访问初始节点v，并标记节点v为已访问。</li>
<li>查找节点v的第一个邻接节点w。</li>
<li>若w存在，再继续执行4,如果不存在，则回到第一步，将从v的下一个节点继续。</li>
<li>若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。</li>
<li>查找节点v的w邻接节点的下一个邻接节点，转到步骤3.</li>
</ol>
<h3 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h3><p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clearState</span><span class="params">(<span class="keyword">boolean</span>[] isVisited)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;isVisited.length;i++) &#123;</span><br><span class="line">			isVisited[i] = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//得到第一个邻接节点的下标</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 如果存在返回对应下标，否则返回-1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;vertexList.size();j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(edges[index][j]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据前一个邻接节点的下标来获取下一个邻接节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = v2+<span class="number">1</span>;j&lt;vertexList.size();j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(edges[v1][j] &gt;<span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//深度优先遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//首先访问该节点</span></span><br><span class="line">		System.out.print(getValueByIndex(i)+<span class="string">"-&gt;"</span>);</span><br><span class="line">		<span class="comment">//将该节点设置为已经访问过</span></span><br><span class="line">		isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> w = getFirstNeighbor(i);</span><br><span class="line">		<span class="keyword">while</span>(w!=-<span class="number">1</span>) &#123;<span class="comment">//有邻接节点</span></span><br><span class="line">			<span class="comment">//判断有没有访问过</span></span><br><span class="line">			<span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">				dfs(isVisited,w);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果w节点已经被访问过，去找邻接点的下一个</span></span><br><span class="line">			w = getNextNeighbor(i, w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对dfs进行重载，遍历所有的节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		clearState(isVisited);</span><br><span class="line">		<span class="comment">//遍历所有节点进行dfs</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;getNumOfVertex();i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">				dfs(isVisited,i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h2><h3 id="图的广度优先遍历基本思想"><a href="#图的广度优先遍历基本思想" class="headerlink" title="图的广度优先遍历基本思想"></a>图的广度优先遍历基本思想</h3><ol>
<li>图的广度优先搜索（BFS(Broad First Search)）</li>
<li>类似于一个分层搜索的过程，广度优先遍历需要使用一个队列已保证访问过的节点的顺序，以便按这个顺序来访问这些节点的邻接节点。</li>
</ol>
<h3 id="广度优先遍历算法步骤"><a href="#广度优先遍历算法步骤" class="headerlink" title="广度优先遍历算法步骤"></a>广度优先遍历算法步骤</h3><ol>
<li>访问初始节点v并标记节点v为已访问。</li>
<li>节点v入队列。</li>
<li>当队列非空时，继续执行，否则算法结束。</li>
<li>出队列，取得队头节点u,</li>
<li>查找节点u的第一个邻接节点w</li>
<li>若节点u的邻接节点w不存在，则转到步骤3；否则循环执行以下三个步骤：<ol>
<li>若节点w尚未被访问，则访问节点w并标记为已访问。</li>
<li>节点w入队列</li>
<li>查找节点u的w邻接节点后的下一个邻接节点w，转到步骤6。</li>
</ol>
</li>
</ol>
<h3 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对一个节点进行广度优先</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> u;<span class="comment">//表示队列的头结点对应的下标</span></span><br><span class="line">		<span class="keyword">int</span> w;<span class="comment">//邻接点下标</span></span><br><span class="line">		<span class="comment">//队列，节点访问顺序</span></span><br><span class="line">		LinkedList queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">		<span class="comment">//访问节点</span></span><br><span class="line">		System.out.print(getValueByIndex(i)+<span class="string">"-&gt;"</span>);</span><br><span class="line">		<span class="comment">//标记为已访问</span></span><br><span class="line">		isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">		<span class="comment">//将节点加入队列</span></span><br><span class="line">		queue.addLast(i);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">			<span class="comment">//取出队列头结点下标</span></span><br><span class="line">			u = (Integer)queue.removeFirst();</span><br><span class="line">			<span class="comment">//得到第一个邻接点的下标</span></span><br><span class="line">			w = getFirstNeighbor(u);</span><br><span class="line">			<span class="keyword">while</span>(w!=-<span class="number">1</span>) &#123;<span class="comment">//找到</span></span><br><span class="line">				<span class="comment">//是否访问过</span></span><br><span class="line">				<span class="keyword">if</span>(!isVisited[w]) &#123;</span><br><span class="line">					System.out.print(getValueByIndex(w)+<span class="string">"—&gt;"</span>);</span><br><span class="line">					<span class="comment">//标记访问</span></span><br><span class="line">					isVisited[w] = <span class="keyword">true</span>;</span><br><span class="line">					<span class="comment">//入队</span></span><br><span class="line">					queue.addLast(w);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//以u为前驱点，找w后面的邻接点</span></span><br><span class="line">				w=getNextNeighbor(u, w);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//遍历所有的节点都进行广度优先搜索</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//我先把是否访问变为false</span></span><br><span class="line">		clearState(isVisited);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;getNumOfVertex();i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!isVisited[i]) &#123;</span><br><span class="line">				dfs(isVisited,i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechat.jpg" alt="李义 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/aipay.png" alt="李义 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
    
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a>
          
            <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="fa fa-tag"></i> 数据结构</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/04/Python%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/" rel="next" title="Python之网络爬虫">
                <i class="fa fa-chevron-left"></i> Python之网络爬虫
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/03/HTML/" rel="prev" title="HTML">
                HTML <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/touxiang.jpg"
                alt="李义" />
            
              <p class="site-author-name" itemprop="name">李义</p>
              <p class="site-description motion-element" itemprop="description">这里写描述</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#java数据结构"><span class="nav-number">1.</span> <span class="nav-text">java数据结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">2.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#稀疏sparsearray数组"><span class="nav-number">3.</span> <span class="nav-text">稀疏sparsearray数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍"><span class="nav-number">3.1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用实例"><span class="nav-number">3.2.</span> <span class="nav-text">应用实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二维数组与稀疏矩阵互相转换的思路"><span class="nav-number">3.3.</span> <span class="nav-text">二维数组与稀疏矩阵互相转换的思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二维-转-稀疏"><span class="nav-number">3.3.1.</span> <span class="nav-text">二维 转 稀疏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#稀疏-转-二维数组"><span class="nav-number">3.3.2.</span> <span class="nav-text">稀疏 转 二维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现"><span class="nav-number">3.3.3.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#队列"><span class="nav-number">4.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#队列介绍"><span class="nav-number">4.1.</span> <span class="nav-text">队列介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组模拟队列"><span class="nav-number">4.2.</span> <span class="nav-text">数组模拟队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环队列"><span class="nav-number">4.3.</span> <span class="nav-text">循环队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分析"><span class="nav-number">4.3.1.</span> <span class="nav-text">分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写环形队列思路"><span class="nav-number">4.3.2.</span> <span class="nav-text">编写环形队列思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-1"><span class="nav-number">4.3.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么循环队列要空一个空间作为约定？"><span class="nav-number">4.3.4.</span> <span class="nav-text">为什么循环队列要空一个空间作为约定？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链表"><span class="nav-number">5.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#单链表"><span class="nav-number">5.1.</span> <span class="nav-text">单链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单链表案例"><span class="nav-number">5.1.1.</span> <span class="nav-text">单链表案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义节点类"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">定义节点类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#定义单链表类"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">定义单链表类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#添加节点"><span class="nav-number">5.1.1.2.1.</span> <span class="nav-text">添加节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#显示链表内容"><span class="nav-number">5.1.1.2.2.</span> <span class="nav-text">显示链表内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#修改节点内容"><span class="nav-number">5.1.1.2.3.</span> <span class="nav-text">修改节点内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#删除节点"><span class="nav-number">5.1.1.2.4.</span> <span class="nav-text">删除节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#代码综合"><span class="nav-number">5.1.1.2.5.</span> <span class="nav-text">代码综合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#测试代码"><span class="nav-number">5.1.1.2.6.</span> <span class="nav-text">测试代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单链表面试题"><span class="nav-number">5.1.2.</span> <span class="nav-text">单链表面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-求单链表中有效节点的个数。"><span class="nav-number">5.1.2.0.1.</span> <span class="nav-text">1.求单链表中有效节点的个数。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-查找单链表中倒数第K个节点"><span class="nav-number">5.1.2.0.2.</span> <span class="nav-text">2.查找单链表中倒数第K个节点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-单链表的反转，有难度"><span class="nav-number">5.1.2.0.3.</span> <span class="nav-text">3.单链表的反转，有难度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-从尾到头打印单链表"><span class="nav-number">5.1.2.0.4.</span> <span class="nav-text">4.从尾到头打印单链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-合并两个有序单链表，结果仍然有序"><span class="nav-number">5.1.2.0.5.</span> <span class="nav-text">5.合并两个有序单链表，结果仍然有序</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双向链表"><span class="nav-number">5.2.</span> <span class="nav-text">双向链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#双向链表增删改查操作"><span class="nav-number">5.2.1.</span> <span class="nav-text">双向链表增删改查操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加操作"><span class="nav-number">5.2.2.</span> <span class="nav-text">添加操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改操作"><span class="nav-number">5.2.3.</span> <span class="nav-text">修改操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除操作"><span class="nav-number">5.2.4.</span> <span class="nav-text">删除操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显示链表"><span class="nav-number">5.2.5.</span> <span class="nav-text">显示链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#环形链表与约瑟夫问题"><span class="nav-number">5.3.</span> <span class="nav-text">环形链表与约瑟夫问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#约瑟夫问题"><span class="nav-number">5.3.1.</span> <span class="nav-text">约瑟夫问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环链表"><span class="nav-number">5.3.2.</span> <span class="nav-text">循环链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#约瑟夫问题解题思路"><span class="nav-number">5.3.3.</span> <span class="nav-text">约瑟夫问题解题思路</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建小孩节点"><span class="nav-number">5.3.3.1.</span> <span class="nav-text">创建小孩节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建环形链表"><span class="nav-number">5.3.3.2.</span> <span class="nav-text">创建环形链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历环形链表"><span class="nav-number">5.3.3.3.</span> <span class="nav-text">遍历环形链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小孩出圈"><span class="nav-number">5.3.3.4.</span> <span class="nav-text">小孩出圈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#环形链表整合"><span class="nav-number">5.3.3.5.</span> <span class="nav-text">环形链表整合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测试代码-1"><span class="nav-number">5.3.3.6.</span> <span class="nav-text">测试代码</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#栈"><span class="nav-number">6.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#栈的介绍"><span class="nav-number">6.1.</span> <span class="nav-text">栈的介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈的应用场景"><span class="nav-number">6.2.</span> <span class="nav-text">栈的应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈的快速入门"><span class="nav-number">6.3.</span> <span class="nav-text">栈的快速入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数组实现栈"><span class="nav-number">6.3.1.</span> <span class="nav-text">数组实现栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单链表实现栈"><span class="nav-number">6.3.2.</span> <span class="nav-text">单链表实现栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈实现综合计算器（中缀表达式）"><span class="nav-number">6.3.3.</span> <span class="nav-text">栈实现综合计算器（中缀表达式）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#递归"><span class="nav-number">7.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#递归的概念"><span class="nav-number">7.1.</span> <span class="nav-text">递归的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归举例"><span class="nav-number">7.2.</span> <span class="nav-text">递归举例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归能解决什么样的问题"><span class="nav-number">7.3.</span> <span class="nav-text">递归能解决什么样的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归需要遵守什么样的规则"><span class="nav-number">7.4.</span> <span class="nav-text">递归需要遵守什么样的规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迷宫回溯"><span class="nav-number">7.5.</span> <span class="nav-text">迷宫回溯</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八皇后问题"><span class="nav-number">7.6.</span> <span class="nav-text">八皇后问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题介绍"><span class="nav-number">7.6.1.</span> <span class="nav-text">问题介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路分析"><span class="nav-number">7.6.2.</span> <span class="nav-text">思路分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-2"><span class="nav-number">7.6.3.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#排序算法"><span class="nav-number">8.</span> <span class="nav-text">排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#排序算法介绍"><span class="nav-number">8.1.</span> <span class="nav-text">排序算法介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序的分类"><span class="nav-number">8.2.</span> <span class="nav-text">排序的分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见排序算法"><span class="nav-number">8.3.</span> <span class="nav-text">常见排序算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间复杂度与空间复杂度"><span class="nav-number">8.4.</span> <span class="nav-text">时间复杂度与空间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡排序"><span class="nav-number">8.5.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序"><span class="nav-number">8.6.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入排序"><span class="nav-number">8.7.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#希尔排序"><span class="nav-number">8.8.</span> <span class="nav-text">希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单插入排序可能存在的问题"><span class="nav-number">8.8.1.</span> <span class="nav-text">简单插入排序可能存在的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#希尔排序介绍"><span class="nav-number">8.8.2.</span> <span class="nav-text">希尔排序介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本思想"><span class="nav-number">8.8.3.</span> <span class="nav-text">基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#希尔排序示意图"><span class="nav-number">8.8.4.</span> <span class="nav-text">希尔排序示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#希尔排序——交换法实现"><span class="nav-number">8.8.5.</span> <span class="nav-text">希尔排序——交换法实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#希尔排序——移位法实现"><span class="nav-number">8.8.6.</span> <span class="nav-text">希尔排序——移位法实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序"><span class="nav-number">8.9.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#归并排序"><span class="nav-number">8.10.</span> <span class="nav-text">归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#归并排序思想示意图1"><span class="nav-number">8.10.1.</span> <span class="nav-text">归并排序思想示意图1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归并排序思想示意图2–合并相邻有序子序列"><span class="nav-number">8.10.2.</span> <span class="nav-text">归并排序思想示意图2–合并相邻有序子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-3"><span class="nav-number">8.10.3.</span> <span class="nav-text">代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#合并方法"><span class="nav-number">8.10.3.1.</span> <span class="nav-text">合并方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分-合"><span class="nav-number">8.10.3.2.</span> <span class="nav-text">分+合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基数排序"><span class="nav-number">8.11.</span> <span class="nav-text">基数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基数排序的基本思想"><span class="nav-number">8.11.1.</span> <span class="nav-text">基数排序的基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基数排序示意图"><span class="nav-number">8.11.2.</span> <span class="nav-text">基数排序示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基数排序代码实现"><span class="nav-number">8.11.3.</span> <span class="nav-text">基数排序代码实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基数排序说明"><span class="nav-number">8.11.4.</span> <span class="nav-text">基数排序说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用排序算法总结和对比"><span class="nav-number">8.12.</span> <span class="nav-text">常用排序算法总结和对比</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#查找算法"><span class="nav-number">9.</span> <span class="nav-text">查找算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#查找算法介绍"><span class="nav-number">9.1.</span> <span class="nav-text">查找算法介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线性查找"><span class="nav-number">9.2.</span> <span class="nav-text">线性查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分查找"><span class="nav-number">9.3.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插值查找"><span class="nav-number">9.4.</span> <span class="nav-text">插值查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#斐波那契查询"><span class="nav-number">9.5.</span> <span class="nav-text">斐波那契查询</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#哈希表"><span class="nav-number">10.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希表（散列）-Google上机题"><span class="nav-number">10.1.</span> <span class="nav-text">哈希表（散列）-Google上机题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#哈希表基本介绍"><span class="nav-number">10.2.</span> <span class="nav-text">哈希表基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现哈希表-数组-链表"><span class="nav-number">10.3.</span> <span class="nav-text">实现哈希表 数组+链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#准备工作"><span class="nav-number">10.3.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现链表的增删改查方法"><span class="nav-number">10.3.2.</span> <span class="nav-text">实现链表的增删改查方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#增加不考虑顺序"><span class="nav-number">10.3.2.1.</span> <span class="nav-text">增加不考虑顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#增加考虑顺序"><span class="nav-number">10.3.2.2.</span> <span class="nav-text">增加考虑顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历操作"><span class="nav-number">10.3.2.3.</span> <span class="nav-text">遍历操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询操作"><span class="nav-number">10.3.2.4.</span> <span class="nav-text">查询操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除操作-1"><span class="nav-number">10.3.2.5.</span> <span class="nav-text">删除操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希表-1"><span class="nav-number">10.3.3.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#散列函数"><span class="nav-number">10.3.3.1.</span> <span class="nav-text">散列函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#增加操作"><span class="nav-number">10.3.3.2.</span> <span class="nav-text">增加操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#遍历操作-1"><span class="nav-number">10.3.3.3.</span> <span class="nav-text">遍历操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询操作-1"><span class="nav-number">10.3.3.4.</span> <span class="nav-text">查询操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除操作-2"><span class="nav-number">10.3.3.5.</span> <span class="nav-text">删除操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码整合-测试"><span class="nav-number">10.3.4.</span> <span class="nav-text">代码整合+测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#树结构的基础部分"><span class="nav-number">11.</span> <span class="nav-text">树结构的基础部分</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树"><span class="nav-number">11.1.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么需要树这种数据结构"><span class="nav-number">11.1.1.</span> <span class="nav-text">为什么需要树这种数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树的示意图"><span class="nav-number">11.1.2.</span> <span class="nav-text">树的示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的概念"><span class="nav-number">11.1.3.</span> <span class="nav-text">二叉树的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树遍历的说明"><span class="nav-number">11.1.4.</span> <span class="nav-text">二叉树遍历的说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树遍历"><span class="nav-number">11.1.5.</span> <span class="nav-text">二叉树遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代码实现-4"><span class="nav-number">11.1.5.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树查找指定节点"><span class="nav-number">11.1.6.</span> <span class="nav-text">二叉树查找指定节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代码实现-5"><span class="nav-number">11.1.6.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树删除节点"><span class="nav-number">11.1.7.</span> <span class="nav-text">二叉树删除节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序存储二叉树"><span class="nav-number">11.2.</span> <span class="nav-text">顺序存储二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">11.2.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序存储二叉树的特点"><span class="nav-number">11.2.2.</span> <span class="nav-text">顺序存储二叉树的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现前序遍历"><span class="nav-number">11.2.3.</span> <span class="nav-text">实现前序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线索化二叉树"><span class="nav-number">11.3.</span> <span class="nav-text">线索化二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#提出问题"><span class="nav-number">11.3.1.</span> <span class="nav-text">提出问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线索二叉树基本介绍"><span class="nav-number">11.3.2.</span> <span class="nav-text">线索二叉树基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线索二叉树应用案例"><span class="nav-number">11.3.3.</span> <span class="nav-text">线索二叉树应用案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#代码实现-6"><span class="nav-number">11.3.3.1.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆排序"><span class="nav-number">11.4.</span> <span class="nav-text">堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本介绍-1"><span class="nav-number">11.4.1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆排序基本思想"><span class="nav-number">11.4.2.</span> <span class="nav-text">堆排序基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆排序步骤图解说明"><span class="nav-number">11.4.3.</span> <span class="nav-text">堆排序步骤图解说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#步骤一"><span class="nav-number">11.4.3.1.</span> <span class="nav-text">步骤一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#步骤2"><span class="nav-number">11.4.3.2.</span> <span class="nav-text">步骤2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆排序代码实现"><span class="nav-number">11.4.4.</span> <span class="nav-text">堆排序代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#赫夫曼树"><span class="nav-number">12.</span> <span class="nav-text">赫夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍-2"><span class="nav-number">12.1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几个重要的概念"><span class="nav-number">12.2.</span> <span class="nav-text">几个重要的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#赫夫曼树创建"><span class="nav-number">12.3.</span> <span class="nav-text">赫夫曼树创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建步骤"><span class="nav-number">12.3.0.1.</span> <span class="nav-text">创建步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图解"><span class="nav-number">12.3.1.</span> <span class="nav-text">图解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-7"><span class="nav-number">12.3.2.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#赫夫曼编码"><span class="nav-number">13.</span> <span class="nav-text">赫夫曼编码</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍-3"><span class="nav-number">13.1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原理剖析"><span class="nav-number">13.2.</span> <span class="nav-text">原理剖析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据压缩"><span class="nav-number">13.3.</span> <span class="nav-text">数据压缩</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编写获取存放节点的集合方法"><span class="nav-number">13.3.1.</span> <span class="nav-text">编写获取存放节点的集合方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建赫夫曼树"><span class="nav-number">13.3.2.</span> <span class="nav-text">创建赫夫曼树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成赫夫曼树对应的赫夫曼编码"><span class="nav-number">13.3.3.</span> <span class="nav-text">生成赫夫曼树对应的赫夫曼编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#得到一个赫夫曼编码表处理后的byte-数组"><span class="nav-number">13.3.4.</span> <span class="nav-text">得到一个赫夫曼编码表处理后的byte[]数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最后将上方步骤进行封装"><span class="nav-number">13.3.5.</span> <span class="nav-text">最后将上方步骤进行封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试"><span class="nav-number">13.3.6.</span> <span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据解压"><span class="nav-number">13.4.</span> <span class="nav-text">数据解压</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实践-文件压缩与解压"><span class="nav-number">13.5.</span> <span class="nav-text">实践-文件压缩与解压</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#赫夫曼编码压缩文件注意事项"><span class="nav-number">13.6.</span> <span class="nav-text">赫夫曼编码压缩文件注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉排序树"><span class="nav-number">14.</span> <span class="nav-text">二叉排序树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#先看一个需求"><span class="nav-number">14.1.</span> <span class="nav-text">先看一个需求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决方案分析"><span class="nav-number">14.2.</span> <span class="nav-text">解决方案分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉排序树介绍"><span class="nav-number">14.3.</span> <span class="nav-text">二叉排序树介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的创建和遍历"><span class="nav-number">14.4.</span> <span class="nav-text">二叉树的创建和遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#首先创建节点类"><span class="nav-number">14.4.1.</span> <span class="nav-text">首先创建节点类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建二叉排序树"><span class="nav-number">14.4.2.</span> <span class="nav-text">创建二叉排序树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉排序树的删除"><span class="nav-number">14.5.</span> <span class="nav-text">二叉排序树的删除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路分析-1"><span class="nav-number">14.5.1.</span> <span class="nav-text">思路分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-8"><span class="nav-number">14.5.2.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二叉平衡树（AVL树）"><span class="nav-number">15.</span> <span class="nav-text">二叉平衡树（AVL树）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉排序树可能的问题"><span class="nav-number">15.1.</span> <span class="nav-text">二叉排序树可能的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍-4"><span class="nav-number">15.2.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用案例–单旋转（右旋转）"><span class="nav-number">15.3.</span> <span class="nav-text">应用案例–单旋转（右旋转）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用案例–单旋转（左旋转）"><span class="nav-number">15.4.</span> <span class="nav-text">应用案例–单旋转（左旋转）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用案例双旋转"><span class="nav-number">15.5.</span> <span class="nav-text">应用案例双旋转</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一种情况：满足右旋转，并且当前节点左子树的右子树高度，大于左子树高度"><span class="nav-number">15.5.1.</span> <span class="nav-text">第一种情况：满足右旋转，并且当前节点左子树的右子树高度，大于左子树高度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二种情况：满足左旋转，当前节点右子树的左子树高度，大于右子树高度"><span class="nav-number">15.5.2.</span> <span class="nav-text">第二种情况：满足左旋转，当前节点右子树的左子树高度，大于右子树高度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#应用案例代码整合"><span class="nav-number">15.6.</span> <span class="nav-text">应用案例代码整合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多路查找树"><span class="nav-number">16.</span> <span class="nav-text">多路查找树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树的问题"><span class="nav-number">16.1.</span> <span class="nav-text">二叉树的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多叉树"><span class="nav-number">16.2.</span> <span class="nav-text">多叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B树的基本介绍"><span class="nav-number">16.3.</span> <span class="nav-text">B树的基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3树"><span class="nav-number">16.4.</span> <span class="nav-text">2-3树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#案例"><span class="nav-number">16.4.1.</span> <span class="nav-text">案例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B树，B-树和B-树"><span class="nav-number">17.</span> <span class="nav-text">B树，B+树和B*树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#B树"><span class="nav-number">17.1.</span> <span class="nav-text">B树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-树"><span class="nav-number">17.2.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-树-1"><span class="nav-number">17.3.</span> <span class="nav-text">B*树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#图"><span class="nav-number">18.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本介绍-5"><span class="nav-number">18.1.</span> <span class="nav-text">基本介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要有图"><span class="nav-number">18.1.1.</span> <span class="nav-text">为什么要有图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的举例"><span class="nav-number">18.1.2.</span> <span class="nav-text">图的举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的基本概念"><span class="nav-number">18.1.3.</span> <span class="nav-text">图的基本概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的表示方式"><span class="nav-number">18.2.</span> <span class="nav-text">图的表示方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#邻接矩阵"><span class="nav-number">18.2.1.</span> <span class="nav-text">邻接矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#邻接表"><span class="nav-number">18.2.2.</span> <span class="nav-text">邻接表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的快速入门"><span class="nav-number">18.3.</span> <span class="nav-text">图的快速入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的深度优先遍历"><span class="nav-number">18.4.</span> <span class="nav-text">图的深度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图遍历介绍"><span class="nav-number">18.4.1.</span> <span class="nav-text">图遍历介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深度优先遍历基本思想"><span class="nav-number">18.4.2.</span> <span class="nav-text">深度优先遍历基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深度优先遍历算法步骤"><span class="nav-number">18.4.3.</span> <span class="nav-text">深度优先遍历算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-9"><span class="nav-number">18.4.4.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的广度优先遍历"><span class="nav-number">18.5.</span> <span class="nav-text">图的广度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图的广度优先遍历基本思想"><span class="nav-number">18.5.1.</span> <span class="nav-text">图的广度优先遍历基本思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#广度优先遍历算法步骤"><span class="nav-number">18.5.2.</span> <span class="nav-text">广度优先遍历算法步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码实现-10"><span class="nav-number">18.5.3.</span> <span class="nav-text">代码实现</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李义</span>

  
</div>
<!--


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>

-->


<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">symbols_count_time.count_total：</span>
    
  <span title="Site words total count">
     147.1k字 </span>
    <!--<span title="symbols_count_time.count_total">455k</span>-->
  
  <div class="theme-info">
    <div class="powered-by"></div>
    <span class="post-count">博客全站共147.1k字</span>
  </div>
  <!-- 新增访客统计代码 -->

<div class="busuanzi-count">
    <script async="" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="site-uv">
      <i class="fa fa-user"></i>
      访问用户： <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人
    </span>
    <div class="powered-by"></div>
    <span class="site-uv">
      <i class="fa fa-eye"></i>
      访问次数： <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次
    </span>
    <!-- 博客字数统计 -->
    <span class="site-pv">
      <i class="fa fa-pencil"></i>
      博客全站共： <span class="post-count">147.1k</span> 字
    </span>
</div>
<!-- 新增访客统计代码 END-->


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("HHo5ARpd4p1yPoBL3xYEgcNV-gzGzoHsz", "2SnHYdpQzjgbCuF8NdQlghh");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

  
  <!-- 代码块复制功能 -->
  <script type="text/javascript" src="/js/src/clipboard.min.js"></script>  
  <script type="text/javascript" src="/js/src/clipboard-use.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
